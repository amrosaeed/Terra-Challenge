{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { FieldNode, SelectionSetNode } from 'graphql';\n\nimport { NormalizedCache } from './types';\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  ReconcilerFunction,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../../utilities';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\n// Invoking merge functions needs to happen after processSelectionSet has\n// finished, but requires information that is more readily available\n// during processSelectionSet, so processSelectionSet embeds special\n// objects of the following shape within its result tree, which then must\n// be removed by calling Policies#applyMerges.\nexport interface FieldValueToBeMerged {\n  __field: FieldNode;\n  __typename: string;\n  __value: StoreValue;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return value !== null &&\n    typeof value === \"object\" &&\n    !isReference(value) &&\n    !Array.isArray(value);\n}\n\nexport function isFieldValueToBeMerged(\n  value: any,\n): value is FieldValueToBeMerged {\n  const field = value && value.__field;\n  return field && isField(field);\n}\n\nexport function makeProcessedFieldsMerger() {\n  // A DeepMerger that merges arrays and objects structurally, but otherwise\n  // prefers incoming scalar values over existing values. Provides special\n  // treatment for FieldValueToBeMerged objects. Used to accumulate fields\n  // when processing a single selection set.\n  return new DeepMerger(reconcileProcessedFields);\n}\n\nconst reconcileProcessedFields: ReconcilerFunction<[]> = function (\n  existingObject,\n  incomingObject,\n  property,\n) {\n  const existing = existingObject[property];\n  const incoming = incomingObject[property];\n\n  if (isFieldValueToBeMerged(existing)) {\n    existing.__value = this.merge(\n      existing.__value,\n      isFieldValueToBeMerged(incoming)\n        // TODO Check compatibility of __field and __typename properties?\n        ? incoming.__value\n        : incoming,\n    );\n    return existing;\n  }\n\n  if (isFieldValueToBeMerged(incoming)) {\n    incoming.__value = this.merge(\n      existing,\n      incoming.__value,\n    );\n    return incoming;\n  }\n\n  return this.merge(existing, incoming);\n}\n"]}