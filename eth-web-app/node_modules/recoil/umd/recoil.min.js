!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("react-dom"),require("react")):"function"==typeof define&&define.amd?define(["exports","react-dom","react"],factory):factory((global=global||self).Recoil={},global.ReactDOM,global.React)}(this,(function(exports,reactDom,react){"use strict";reactDom=reactDom&&Object.prototype.hasOwnProperty.call(reactDom,"default")?reactDom.default:reactDom,react=react&&Object.prototype.hasOwnProperty.call(react,"default")?react.default:react;const gks=new Map;function Recoil_gkx(gk){var _gks$get;return null!==(_gks$get=gks.get(gk))&&void 0!==_gks$get&&_gks$get}Recoil_gkx.setPass=gk=>{gks.set(gk,!0)},Recoil_gkx.setFail=gk=>{gks.set(gk,!1)};var Recoil_gkx_1=Recoil_gkx;var Recoil_mapMap=function(map,callback){const result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw new Error(null!=message?message:"Got unexpected null or undefined")};var Recoil_recoverableViolation=function(message,projectName,{error:error}={}){return null};var Recoil_Tracing={trace:function(message,node,fn){return fn()},wrap:function(fn){return fn}};var Recoil_CopyOnWrite={setByAddingToSet:function(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function(map,ks){const next=new Map(map);return ks.forEach(k=>next.delete(k)),next}};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});class DefaultValue{}const DEFAULT_VALUE=new DefaultValue;class RecoilValueNotReady extends Error{constructor(key){super(`Tried to set the value of Recoil selector ${key} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}var Recoil_Node={nodes:nodes,recoilValues:recoilValues,registerNode:function(node){if(nodes.has(node.key)){const message=`Duplicate atom key "${node.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function(key){return nodes.get(key)},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE,RecoilValueNotReady:RecoilValueNotReady};const{mapByDeletingFromMap:mapByDeletingFromMap$1,mapBySettingInMap:mapBySettingInMap$1,setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1}=Recoil_Node,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}var Recoil_FunctionalCore={getNodeLoadable:function(store,state,key){return getNode$1(key).get(store,state)},peekNodeLoadable:function(store,state,key){return getNode$1(key).peek(store,state)},setNodeValue:function(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError("Attempt to set read-only RecoilValue: "+key);return node.set(store,state,newValue)},cleanUpNode:function(store,key){getNode$1(key).cleanUp(store)},setUnvalidatedAtomValue_DEPRECATED:function(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:mapByDeletingFromMap$1(state.atomValues,key),nonvalidatedAtoms:mapBySettingInMap$1(state.nonvalidatedAtoms,key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},getDownstreamNodes:function(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}};var Recoil_differenceSets=function(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};function mergeDependencyMapIntoGraph(deps,graph,olderGraph){const{nodeDeps:nodeDeps,nodeToNodeSubscriptions:nodeToNodeSubscriptions}=graph;deps.forEach((upstreams,downstream)=>{const existingUpstreams=nodeDeps.get(downstream);if(existingUpstreams&&olderGraph&&existingUpstreams!==olderGraph.nodeDeps.get(downstream))return;nodeDeps.set(downstream,new Set(upstreams));if((null==existingUpstreams?upstreams:Recoil_differenceSets(upstreams,existingUpstreams)).forEach(upstream=>{nodeToNodeSubscriptions.has(upstream)||nodeToNodeSubscriptions.set(upstream,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream)).add(downstream)}),existingUpstreams){Recoil_differenceSets(existingUpstreams,upstreams).forEach(upstream=>{if(!nodeToNodeSubscriptions.has(upstream))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));existing.delete(downstream),0===existing.size&&nodeToNodeSubscriptions.delete(upstream)})}})}var Recoil_Graph={addToDependencyMap:function(downstream,upstream,dependencyMap){dependencyMap.has(downstream)||dependencyMap.set(downstream,new Set),Recoil_nullthrows(dependencyMap.get(downstream)).add(upstream)},cloneGraph:function(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,s=>new Set(s)),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,s=>new Set(s))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(from,into){from.forEach((upstreamDeps,downstreamNode)=>{into.has(downstreamNode)||into.set(downstreamNode,new Set);const deps=Recoil_nullthrows(into.get(downstreamNode));upstreamDeps.forEach(dep=>deps.add(dep))})},saveDependencyMapToStore:function(dependencyMap,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const graph=store.getGraph(version);if(mergeDependencyMapIntoGraph(dependencyMap,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(nextVersion),graph)}}}};const{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{saveDependencyMapToStore:saveDependencyMapToStore$1}=Recoil_Graph,{getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1,RecoilValueNotReady:RecoilValueNotReady$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1;function applyAction(store,state,action){if("set"===action.type){const{recoilValue:recoilValue,valueOrUpdater:valueOrUpdater}=action,newValue=function(store,state,{key:key},valueOrUpdater){if("function"==typeof valueOrUpdater){const current=getNodeLoadable$1(store,state,key)[1];if("loading"===current.state)throw new RecoilValueNotReady$1(key);if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,state,recoilValue,valueOrUpdater),[depMap,writes]=setNodeValue$1(store,state,recoilValue.key,newValue);saveDependencyMapToStore$1(depMap,store,state.version);for(const[key,loadable]of writes.entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){const{recoilValue:{key:key},loadable:loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){const{recoilValue:{key:key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;const{recoilValue:{key:key},unvalidatedValue:unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else Recoil_recoverableViolation("Unknown action "+action.type)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState(state=>{const newState=function(state){return{...state,atomValues:new Map(state.atomValues),nonvalidatedAtoms:new Map(state.nonvalidatedAtoms),dirtyAtoms:new Set(state.dirtyAtoms)}}(state);for(const action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),newState})}function queueOrPerformStateUpdate(store,action,key,message){if(batchStack.length){const actionsByStore=batchStack[batchStack.length-1];let actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else Recoil_Tracing.trace(message,key,()=>applyActionsToStore(store,[action]))}const batchStack=[];function invalidateDownstreams(store,state){const downstreams=getDownstreamNodes$1(store,state,state.dirtyAtoms);for(const key of downstreams){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue:recoilValue,valueOrUpdater:valueOrUpdater},recoilValue.key,"set Recoil value")}let subscriptionID=0;var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function(store,{key:key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(treeState.version,null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const[dependencyMap,loadable]=getNodeLoadable$1(store,treeState,key);return Recoil_gkx_1("recoil_async_selector_refactor")||saveDependencyMapToStore$1(dependencyMap,store,treeState.version),loadable},setRecoilValue:setRecoilValue,setRecoilValueLoadable:function(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue:recoilValue,loadable:loadable},recoilValue.key,"set Recoil value")},markRecoilValueModified:function(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue:recoilValue},recoilValue.key,"mark RecoilValue modified")},setUnvalidatedRecoilValue:function(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue:recoilValue,unvalidatedValue:unvalidatedValue},recoilValue.key,"set Recoil value")},subscribeToRecoilValue:function(store,{key:key},callback,componentDebugName=null){const subID=subscriptionID++,storeState=store.getState();return storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]),{release:()=>{const storeState=store.getState(),subs=storeState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)&&(subs.delete(subID),0===subs.size&&storeState.nodeToComponentSubscriptions.delete(key))}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function(atomValues,writes){const result=Recoil_mapMap(atomValues,v=>v);return writes.forEach((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)}),result},batchStart:function(){const actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(const[store,actions]of actionsByStore)Recoil_Tracing.trace("Recoil batched updates","-",()=>applyActionsToStore(store,actions));batchStack.pop()}},invalidateDownstreams_FOR_TESTING:invalidateDownstreams};const{unstable_batchedUpdates:unstable_batchedUpdates}=reactDom;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates};const{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$1}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$1;var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher(()=>{let batchEnd=()=>{};try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}})}};var Recoil_Queue={enqueueExecution:function(s,f){f()}};var Recoil_concatIterables=function*(iters){for(const iter of iters)for(const val of iter)yield val};var Recoil_filterIterable=function*(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};var Recoil_mapIterable=function(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};const{graph:graph$1}=Recoil_Graph;let nextTreeStateVersion=0;const getNextTreeStateVersion=()=>nextTreeStateVersion++;function makeEmptyTreeState(){const version=getNextTreeStateVersion();return{version:version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:new Map,nonvalidatedAtoms:new Map}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function(){const currentTree=makeEmptyTreeState();return{currentTree:currentTree,nextTree:null,previousTree:null,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph$1()),versionsUsedByComponent:new Map}},getNextTreeStateVersion:getNextTreeStateVersion};const{batchUpdates:batchUpdates$1}=Recoil_Batching,{getDownstreamNodes:getDownstreamNodes$2,peekNodeLoadable:peekNodeLoadable$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1}=Recoil_Node,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1}=Recoil_RecoilValueInterface,{getNextTreeStateVersion:getNextTreeStateVersion$1,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State;function recoilValuesForKeys(keys){return Recoil_mapIterable(keys,key=>Recoil_nullthrows(recoilValues$1.get(key)))}class Snapshot{constructor(storeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"getLoadable",recoilValue=>getRecoilValueAsLoadable$1(this._store,recoilValue)),_defineProperty(this,"getPromise",recoilValue=>this.getLoadable(recoilValue).toPromise()),_defineProperty(this,"getNodes_UNSTABLE",opt=>{if(!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];return recoilValuesForKeys(this._store.getState().currentTree.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys(Recoil_concatIterables([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),({key:key})=>!knownAtoms.has(key)&&!knownSelectors.has(key))}),_defineProperty(this,"getDeps_UNSTABLE",recoilValue=>{this.getLoadable(recoilValue);const deps=this._store.getGraph(this._store.getState().currentTree.version).nodeDeps.get(recoilValue.key);return recoilValuesForKeys(null!=deps?deps:[])}),_defineProperty(this,"getSubscribers_UNSTABLE",({key:key})=>{const state=this._store.getState().currentTree;return{nodes:recoilValuesForKeys(Recoil_filterIterable(getDownstreamNodes$2(this._store,state,new Set([key])),nodeKey=>nodeKey!==key))}}),_defineProperty(this,"getInfo_UNSTABLE",recoilValue=>{var _graph$nodeDeps$get;const{key:key}=recoilValue,state=this._store.getState().currentTree,graph=this._store.getGraph(state.version),type=this._store.getState().knownAtoms.has(key)?"atom":this._store.getState().knownSelectors.has(key)?"selector":void 0;return{loadable:peekNodeLoadable$1(this._store,state,key),isActive:this._store.getState().knownAtoms.has(key)||this._store.getState().knownSelectors.has(key),isSet:"selector"!==type&&state.atomValues.has(key),isModified:state.dirtyAtoms.has(key),type:type,deps:recoilValuesForKeys(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[]),subscribers:this.getSubscribers_UNSTABLE(recoilValue)}}),_defineProperty(this,"map",mapper=>{const mutableSnapshot=new MutableSnapshot(this);return mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),_defineProperty(this,"asyncMap",async mapper=>{const mutableSnapshot=new MutableSnapshot(this);return await mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),this._store={getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}}}getStore_INTERNAL(){return this._store}getID(){return this.getID_INTERNAL()}getID_INTERNAL(){return this._store.getState().currentTree.stateID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$1():treeState.version;return{currentTree:bumpVersion?{version:version,stateID:version,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:new Map(treeState.atomValues),nonvalidatedAtoms:new Map(treeState.nonvalidatedAtoms)}:treeState,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),versionsUsedByComponent:new Map}}function cloneSnapshot(store,version="current"){const storeState=store.getState(),treeState="current"===version?storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState))}class MutableSnapshot extends Snapshot{constructor(snapshot){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0)),_defineProperty(this,"set",(recoilState,newValueOrUpdater)=>{const store=this.getStore_INTERNAL();batchUpdates$1(()=>{setRecoilValue$1(store,recoilState,newValueOrUpdater)})}),_defineProperty(this,"reset",recoilState=>batchUpdates$1(()=>setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1)))}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function(initializeState){const snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot},cloneSnapshot:cloneSnapshot},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});var Recoil_unionSets=function(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};const{useContext:useContext,useEffect:useEffect,useMemo:useMemo,useRef:useRef,useState:useState}=react,{cleanUpNode:cleanUpNode$1,getDownstreamNodes:getDownstreamNodes$3,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$3,saveDependencyMapToStore:saveDependencyMapToStore$2}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{mapByDeletingMultipleFromMap:mapByDeletingMultipleFromMap$1}=Recoil_CopyOnWrite;function notInAContext(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(storeState){if(stateReplacerIsBeingExecuted)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");if(null===storeState.nextTree){const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$2();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react.createContext(null);function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);const dependentNodes=getDownstreamNodes$3(store,treeState,dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}let nodeNames="[available in dev build]";storeState.suspendedComponentResolvers.forEach(cb=>Recoil_Tracing.trace("value became available, waking components",nodeNames,cb))}storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb=>cb(treeState)),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher(props){const storeRef=useStoreRef(),[_,setState]=useState([]);return props.setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>{Recoil_Queue.enqueueExecution("Batcher",()=>{const storeState=storeRef.current.getState(),{nextTree:nextTree}=storeState;if(null===nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(storeRef.current);const discardedVersion=Recoil_nullthrows(storeState.previousTree).version;storeState.graphsByVersion.delete(discardedVersion),storeState.previousTree=null})}),null}let nextID=0;var Recoil_RecoilRoot_react={useStoreRef:useStoreRef,useRecoilMutableSource:()=>useContext(MutableSourceContext),RecoilRoot:function({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,store_INTERNAL:storeProp,children:children}){var _createMutableSource;let storeState;const notifyBatcherOfChange=useRef(null),createMutableSource=null!==(_createMutableSource=react.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react.unstable_createMutableSource,store=null!=storeProp?storeProp:{getState:()=>storeState.current,replaceState:replacer=>{const storeState=storeRef.current.getState();startNextTreeIfNeeded(storeState);const nextTree=Recoil_nullthrows(storeState.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeState.nextTree=replaced,Recoil_nullthrows(notifyBatcherOfChange.current)())},getGraph:version=>{const graphs=storeState.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$3();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:(callback,key)=>{if(null==key){const{transactionSubscriptions:transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions:nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata:metadata=>{startNextTreeIfNeeded(storeRef.current.getState());for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]}},storeRef=useRef(store);storeState=useRef(null!=initializeState_DEPRECATED?function(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,[depMap,writes]=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys());saveDependencyMapToStore$2(depMap,store,state.version);const nonvalidatedAtoms=mapByDeletingMultipleFromMap$1(state.nonvalidatedAtoms,writtenNodes);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms:nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)})}}),initial}(store,initializeState_DEPRECATED):null!=initializeState?function(initializeState){return freshSnapshot$1().map(initializeState).getStore_INTERNAL().getState()}(initializeState):makeEmptyStoreState$2());const mutableSource=useMemo(()=>createMutableSource?createMutableSource(storeState,()=>storeState.current.currentTree.version):null,[createMutableSource,storeState]);return useEffect(()=>()=>{for(const atomKey of storeRef.current.getState().knownAtoms)cleanUpNode$1(storeRef.current,atomKey)},[]),react.createElement(AppContext.Provider,{value:storeRef},react.createElement(MutableSourceContext.Provider,{value:mutableSource},react.createElement(Batcher,{setNotifyBatcherOfChange:function(x){notifyBatcherOfChange.current=x}}),children))},sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};var Recoil_filterMap=function(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_invariant=function(condition,message){if(!condition)throw new Error(message)};var _useMutableSource,Recoil_mergeMaps=function(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const useMutableSource=null!==(_useMutableSource=react.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react.unstable_useMutableSource;var Recoil_mutableSource={mutableSourceExists:function(){return useMutableSource&&!("undefined"!=typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:useMutableSource};const{useRef:useRef$1}=react;var Recoil_useComponentName=function(){return useRef$1(),"<component name not available>"};const{useCallback:useCallback,useEffect:useEffect$1,useMemo:useMemo$1,useRef:useRef$2,useState:useState$1}=react,{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2,getNode:getNode$2,nodes:nodes$1}=Recoil_Node,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$1}=Recoil_RecoilRoot_react,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setRecoilValueLoadable:setRecoilValueLoadable$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{Snapshot:Snapshot$1,cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{mutableSourceExists:mutableSourceExists$1,useMutableSource:useMutableSource$1}=Recoil_mutableSource;function handleLoadable(loadable,atom,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise(resolve=>{storeRef.current.getState().suspendedComponentResolvers.add(resolve)})}throw"hasError"===loadable.state?loadable.contents:new Error(`Invalid value of loadable atom "${atom.key}"`)}function useRecoilValueLoadable(recoilValue){return mutableSourceExists$1()?function(recoilValue){const storeRef=useStoreRef$1(),getValue=useCallback(()=>getRecoilValueAsLoadable$2(storeRef.current,recoilValue,storeRef.current.getState().currentTree),[storeRef,recoilValue]),componentName=Recoil_useComponentName(),subscribe=useCallback((_something,callback)=>{const store=storeRef.current,sub=subscribeToRecoilValue$1(store,recoilValue,()=>{Recoil_Tracing.trace("RecoilValue subscription fired",recoilValue.key,()=>{callback()})},componentName);return()=>sub.release(store)},[recoilValue,storeRef,componentName]);return useMutableSource$1(useRecoilMutableSource$1(),getValue,subscribe)}(recoilValue):function(recoilValue){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName();return useEffect$1(()=>{const store=storeRef.current,sub=subscribeToRecoilValue$1(store,recoilValue,_state=>{Recoil_Tracing.trace("RecoilValue subscription fired",recoilValue.key,()=>{forceUpdate([])})},componentName);return Recoil_Tracing.trace("initial update on subscribing",recoilValue.key,()=>{store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(Recoil_Tracing.wrap(()=>{forceUpdate([])})):forceUpdate([])}),()=>sub.release(store)},[recoilValue,storeRef]),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}(recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$1();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$1();return useCallback(newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)},[storeRef,recoilState])}function useTransactionSubscription(callback){const storeRef=useStoreRef$1();useEffect$1(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues,persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,(v,k)=>{const persistence=getNode$2(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms,persistedAtomContentsValues)}function useGotoRecoilSnapshot(){const storeRef=useStoreRef$1();return useCallback(snapshot=>{var _storeState$nextTree;const storeState=storeRef.current.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$2(()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$2(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach(key=>{setRecoilValueLoadable$1(storeRef.current,new AbstractRecoilValue$2(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$2)}),storeRef.current.replaceState(state=>({...state,stateID:snapshot.getID_INTERNAL()}))})},[storeRef])}class Sentinel{}const SENTINEL=new Sentinel;var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:useGotoRecoilSnapshot,useRecoilCallback:function(fn,deps){const storeRef=useStoreRef$1(),gotoSnapshot=useGotoRecoilSnapshot();return useCallback((...args)=>{const snapshot=cloneSnapshot$1(storeRef.current);function set(recoilState,newValueOrUpdater){setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}function reset(recoilState){setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}let ret=SENTINEL;return batchUpdates$2(()=>{ret=fn({set:set,reset:reset,snapshot:snapshot,gotoSnapshot:gotoSnapshot})(...args)}),ret instanceof Sentinel&&Recoil_invariant(!1),ret},null!=deps?[...deps,storeRef]:void 0)},useRecoilInterface:function(){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$2(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$2(new Set),subscriptions=useRef$2(new Map),unsubscribeFrom=useCallback(key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(storeRef.current),subscriptions.current.delete(key))},[storeRef,subscriptions]),componentName=Recoil_useComponentName();return useEffect$1(()=>{const store=storeRef.current;function updateState(_state,key){subscriptions.current.has(key)&&forceUpdate([])}Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key))return;const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$2(key),state=>{Recoil_Tracing.trace("RecoilValue subscription fired",key,()=>{updateState(0,key)})},componentName);subscriptions.current.set(key,sub),Recoil_Tracing.trace("initial update on subscribing",key,()=>{store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(Recoil_Tracing.wrap(()=>{updateState(store.getState(),key)})):updateState(store.getState(),key)})}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$1(()=>{const subs=subscriptions.current;return()=>subs.forEach((_,key)=>unsubscribeFrom(key))},[unsubscribeFrom]),useMemo$1(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){return recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key)),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])},useRecoilSnapshot:function(){const storeRef=useStoreRef$1(),[snapshot,setSnapshot]=useState$1(()=>cloneSnapshot$1(storeRef.current));return useTransactionSubscription(useCallback(store=>setSnapshot(cloneSnapshot$1(store)),[])),snapshot},useRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilTransactionObserver:function(callback){useTransactionSubscription(useCallback(store=>{callback({snapshot:cloneSnapshot$1(store,"current"),previousSnapshot:cloneSnapshot$1(store,"previous")})},[callback]))},useRecoilValue:useRecoilValue,useRecoilValueLoadable:useRecoilValueLoadable,useResetRecoilState:function(recoilState){const storeRef=useStoreRef$1();return useCallback(()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)},[storeRef,recoilState])},useSetRecoilState:useSetRecoilState,useSetUnvalidatedAtomValues:function(){const storeRef=useStoreRef$1();return(values,transactionMetadata={})=>{batchUpdates$2(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$1(storeRef.current,new AbstractRecoilValue$2(key),value))})}},useTransactionObservation_DEPRECATED:function(callback){useTransactionSubscription(useCallback(store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}}),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,k=>atomValues.has(k)||previousAtomValues.has(k));callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})},[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{useMemo:useMemo$2}=react,{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$2}=Recoil_RecoilRoot_react;var Recoil_useRecoilBridgeAcrossReactRoots=function(){const store=useStoreRef$2().current;return useMemo$2(()=>function({children:children}){return react.createElement(RecoilRoot$1,{store_INTERNAL:store},children)},[store])};var Recoil_isPromise=function(p){return!!p&&"function"==typeof p.then};const loadableAccessors={getValue(){if("loading"===this.state&&Recoil_gkx_1("recoil_async_selector_refactor"))throw this.contents.then(({__value:__value})=>__value);if("hasValue"!==this.state)throw this.contents;return this.contents},toPromise(){return"hasValue"===this.state?Promise.resolve(this.contents):"hasError"===this.state?Promise.reject(this.contents):Recoil_gkx_1("recoil_async_selector_refactor")?this.contents.then(({__value:__value})=>__value):this.contents},valueMaybe(){return"hasValue"===this.state?this.contents:void 0},valueOrThrow(){if("hasValue"!==this.state)throw new Error(`Loadable expected value, but in "${this.state}" state`);return this.contents},errorMaybe(){return"hasError"===this.state?this.contents:void 0},errorOrThrow(){if("hasError"!==this.state)throw new Error(`Loadable expected error, but in "${this.state}" state`);return this.contents},promiseMaybe(){return"loading"===this.state?Recoil_gkx_1("recoil_async_selector_refactor")?this.contents.then(({__value:__value})=>__value):this.contents:void 0},promiseOrThrow(){if("loading"!==this.state)throw new Error(`Loadable expected promise, but in "${this.state}" state`);return Recoil_gkx_1("recoil_async_selector_refactor")?this.contents.then(({__value:__value})=>__value):this.contents},map(map){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>map(this.contents))):loadableWithError(e)}if("loading"===this.state)return loadableWithPromise(this.contents.then(map).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>map(this.contents));throw e}));throw new Error("Invalid Loadable state")}};function loadableWithValue(value){return Object.freeze({state:"hasValue",contents:value,...loadableAccessors})}function loadableWithError(error){return Object.freeze({state:"hasError",contents:error,...loadableAccessors})}function loadableWithPromise(promise){return Object.freeze({state:"loading",contents:promise,...loadableAccessors})}var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:function(){return loadableWithPromise(new Promise(()=>{}))},loadableAll:function(inputs){return inputs.every(i=>"hasValue"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>"hasError"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>"hasError"===i.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Recoil_gkx_1("recoil_async_selector_refactor")?Promise.all(inputs.map(i=>i.contents)).then(value=>({__value:value})):Promise.all(inputs.map(i=>i.contents)))}};var Recoil_cacheMostRecent=function(){let mostRecentKey,mostRecentValue;const cache={get:key=>key===mostRecentKey?mostRecentValue:void 0,set:(key,value)=>(mostRecentKey=key,mostRecentValue=value,cache)};return cache};const LEAF=Symbol("ArrayKeyedMap"),emptyMap=new Map;class ArrayKeyedMap{constructor(existing){if(_defineProperty(this,"_base",new Map),existing instanceof ArrayKeyedMap)for(const[k,v]of existing.entries())this.set(k,v);else if(existing)for(const[k,v]of existing)this.set(k,v);return this}get(key){const ks=Array.isArray(key)?key:[key];let map=this._base;return ks.forEach(k=>{var _map$get;map=null!==(_map$get=map.get(k))&&void 0!==_map$get?_map$get:emptyMap}),void 0===map?void 0:map.get(LEAF)}set(key,value){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.set(LEAF,value),this}delete(key){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.delete(LEAF),this}entries(){const answer=[];return function recurse(level,prefix){level.forEach((v,k)=>{k===LEAF?answer.push([prefix,v]):recurse(v,prefix.concat(k))})}(this._base,[]),answer.values()}toBuiltInMap(){return new Map(this.entries())}}var Recoil_ArrayKeyedMap_1=ArrayKeyedMap,Recoil_ArrayKeyedMap$1=Object.freeze({__proto__:null,ArrayKeyedMap:Recoil_ArrayKeyedMap_1});const{ArrayKeyedMap:ArrayKeyedMap$1}=Recoil_ArrayKeyedMap$1;var Recoil_cacheWithReferenceEquality=function(){return new ArrayKeyedMap$1};var Recoil_stableStringify=function(x,opt={allowFunctions:!1}){return function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(key=>void 0!==x[key]).sort().map(key=>`${stringify(key,opt)}:${stringify(x[key],opt,key)}`).join(",")}}`}(x,opt)};var Recoil_cacheWithValueEquality=function(){const map=new Map,cache={get:key=>map.get(Recoil_stableStringify(key)),set:(key,value)=>(map.set(Recoil_stableStringify(key),value),cache),map:map};return cache};var Recoil_nodeCacheMostRecent=function(){let mostRecent;return{get:(getNodeValue,handlers)=>{if(void 0!==mostRecent){for(const[nodeKey,nodeValue]of mostRecent.route){var _handlers$onCacheHit;if(getNodeValue(nodeKey)!==nodeValue)return;null==handlers||null===(_handlers$onCacheHit=handlers.onCacheHit)||void 0===_handlers$onCacheHit||_handlers$onCacheHit.call(handlers,nodeKey)}return mostRecent.value}},set:(route,value)=>{mostRecent={route:route,value:value}},getRoot:()=>mostRecent}};var Recoil_TreeNodeCache={setInTreeCache:function setInTreeCache(root,route,result){if(null==root){if(0===route.length)return{type:"result",result:result};{const[path,...rest]=route,[nodeKey,value]=path;return{type:"branch",nodeKey:nodeKey,branches:new Map([[value,setInTreeCache(null,rest,result)]])}}}if(0===route.length){if("result"!==root.type&&Recoil_invariant(!1),root.result&&"loading"===root.result.state){return{type:"result",result:result}}root.result!==result&&Recoil_invariant(!1);return root}{const[path,...rest]=route,[nodeKey,value]=path;return"branch"!==root.type&&Recoil_invariant(!1),root.nodeKey!==nodeKey&&Recoil_invariant(!1),root.branches.set(value,setInTreeCache(root.branches.get(value),rest,result)),root}},getFromTreeCache:function getFromTreeCache(root,getNodeValue,handlers){var _handlers$onCacheHit;if(null==root)return;if("result"===root.type)return root.result;null==handlers||null===(_handlers$onCacheHit=handlers.onCacheHit)||void 0===_handlers$onCacheHit||_handlers$onCacheHit.call(handlers,root.nodeKey);const nodeValue=getNodeValue(root.nodeKey);return getFromTreeCache(root.branches.get(nodeValue),getNodeValue,handlers)}};const{getFromTreeCache:getFromTreeCache$1,setInTreeCache:setInTreeCache$1}=Recoil_TreeNodeCache;var Recoil_treeCacheReferenceEquality=function(){let treeRoot;return{get:(getNodeValue,handlers)=>getFromTreeCache$1(treeRoot,getNodeValue,handlers),set:(route,result)=>{treeRoot=setInTreeCache$1(treeRoot,route,result)},getRoot:()=>treeRoot}};const{getFromTreeCache:getFromTreeCache$2,setInTreeCache:setInTreeCache$2}=Recoil_TreeNodeCache;var Recoil_treeCacheValueEquality=function(){let treeRoot;return{get:(getNodeValue,handlers)=>getFromTreeCache$2(treeRoot,nodeKey=>Recoil_stableStringify(getNodeValue(nodeKey)),handlers),set:(route,result)=>{treeRoot=setInTreeCache$2(treeRoot,route.map(([nodeKey,nodeValue])=>[nodeKey,Recoil_stableStringify(nodeValue)]),result)},getRoot:()=>treeRoot}};var Recoil_PerformanceTimings={startPerfBlock:function(_id){return()=>null}};const{loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$1}=Recoil_Loadable,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$2,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDependencyMapToStore:saveDependencyMapToStore$3}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$3,RecoilValueNotReady:RecoilValueNotReady$2,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$3}=Recoil_RecoilValue$1,{setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings,emptySet$1=Object.freeze(new Set),dependencyStack=[],waitingStores=new Map,getNewExecutionId=(()=>{let executionId=0;return()=>executionId++})();var Recoil_selector_NEW=function(options){const{key:key,get:get,cacheImplementation_UNSTABLE:cacheImplementation}=options,set=null!=options.set?options.set:void 0,cache=cacheImplementation===Recoil_cacheWithReferenceEquality?Recoil_treeCacheReferenceEquality():cacheImplementation===Recoil_cacheWithValueEquality?Recoil_treeCacheValueEquality():cacheImplementation===Recoil_cacheMostRecent?Recoil_nodeCacheMostRecent():Recoil_treeCacheReferenceEquality(),executionInfo={depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null};function initSelector(store){store.getState().knownSelectors.add(key)}function notifyStoreWhenAsyncSettles(store,loadable,executionId){if("loading"===loadable.state){let stores=waitingStores.get(executionId);null==stores&&waitingStores.set(executionId,stores=new Set),stores.add(store)}}function getCachedNodeLoadable(store,state,key){if(state.atomValues.has(key))return[new Map,Recoil_nullthrows(state.atomValues.get(key))];const[,loadable]=getNodeLoadable$2(store,state,key),isKeyPointingToSelector=store.getState().knownSelectors.has(key);return"loading"!==loadable.state&&isKeyPointingToSelector&&state.atomValues.set(key,loadable),[new Map,loadable]}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionId){return promise.then(resolvedDep=>{const{__key:resolvedDepKey,__value:depValue}=resolvedDep;null!=resolvedDepKey&&state.atomValues.set(resolvedDepKey,loadableWithValue$1(depValue));const[loadable,depValues]=evaluateSelectorGetter(store,state,executionId);if(isLatestExecution(executionId)&&updateExecutionInfoDepValues(depValues,executionId),maybeFreezeLoadableContents(loadable),"loading"!==loadable.state&&(setCache(state,depValuesToDepRoute(depValues),loadable),setLoadableInStoreToNotifyDeps(loadable,executionId)),"hasError"===loadable.state)throw loadable.contents;return"hasValue"===loadable.state?{__value:loadable.contents,__key:key}:loadable.contents}).catch(error=>{const loadable=loadableWithError$1(error);throw setCache(state,depValuesToDepRoute(existingDeps),loadableWithError$1(error)),setLoadableInStoreToNotifyDeps(loadable,executionId),error})}function setLoadableInStoreToNotifyDeps(loadable,executionId){isLatestExecution(executionId)&&(setExecutionInfo(loadable),function(newLoadable,executionId){const stores=waitingStores.get(executionId);if(void 0!==stores){for(const store of stores)setRecoilValueLoadable$2(store,new AbstractRecoilValue$3(key),newLoadable);waitingStores.delete(executionId)}}(loadable,executionId))}function setDepsInStore(store,state,deps,executionId){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;(isLatestExecution(executionId)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState||null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2||null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDependencyMapToStore$3(new Map([[key,deps]]),store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3||null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version)}function setNewDepInStore(store,state,deps,newDepKey,executionId){deps.add(newDepKey),setDepsInStore(store,state,deps,executionId)}function evaluateSelectorGetter(store,state,executionId){const endPerfBlock=startPerfBlock$1(key);let result,loadable;const depValues=new Map,deps=new Set;function getRecoilValue(recoilValue){const{key:depKey}=recoilValue;setNewDepInStore(store,state,deps,depKey,executionId);const[,depLoadable]=getCachedNodeLoadable(store,state,depKey);if(depValues.set(depKey,depLoadable),"hasValue"===depLoadable.state)return depLoadable.contents;throw depLoadable.contents}setDepsInStore(store,state,deps,executionId);try{result=get({get:getRecoilValue}),result=isRecoilValue$2(result)?getRecoilValue(result):result,Recoil_isPromise(result)?result=function(store,promise,state,depValues,executionId){return promise.then(value=>{const loadable=loadableWithValue$1(value);return setCache(state,depValuesToDepRoute(depValues),loadable),setLoadableInStoreToNotifyDeps(loadable,executionId),{__value:value,__key:key}}).catch(errorOrPromise=>{if(isLatestExecution(executionId)&&updateExecutionInfoDepValues(depValues,executionId),Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionId);const loadable=loadableWithError$1(errorOrPromise);throw setCache(state,depValuesToDepRoute(depValues),loadable),setLoadableInStoreToNotifyDeps(loadable,executionId),errorOrPromise})}(store,result,state,depValues,executionId).finally(endPerfBlock):endPerfBlock()}catch(errorOrDepPromise){result=errorOrDepPromise,Recoil_isPromise(result)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionId).finally(endPerfBlock):endPerfBlock()}return loadable=result instanceof Error?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$1(result),maybeFreezeLoadableContents(loadable),[loadable,depValues]}function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map(([key,valLoadable])=>[key,valLoadable.contents])}function getValFromRunningNewExecutionAndUpdatedDeps(store,state){const newExecutionId=getNewExecutionId(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionId);return setExecutionInfo(loadable,newDepValues,newExecutionId,state),function(state,depRoute,loadable){"loading"!==loadable.state&&setCache(state,depRoute,loadable)}(state,depValuesToDepRoute(newDepValues),loadable),notifyStoreWhenAsyncSettles(store,loadable,newExecutionId),loadable}function getSelectorValAndUpdatedDeps(store,state){const cachedVal=function(store,state){var _store$getGraph$nodeD;if(state.atomValues.has(key))return state.atomValues.get(key);const deps=new Set(null!==(_store$getGraph$nodeD=store.getGraph(state.version).nodeDeps.get(key))&&void 0!==_store$getGraph$nodeD?_store$getGraph$nodeD:emptySet$1);return setDepsInStore(store,state,deps,executionInfo.latestExecutionId),cache.get(nodeKey=>{const[,loadable]=getCachedNodeLoadable(store,state,nodeKey);return loadable.contents},{onCacheHit:nodeKey=>{nodeKey!==key&&setNewDepInStore(store,state,deps,nodeKey,executionInfo.latestExecutionId)}})}(store,state);return null!=cachedVal?(setExecutionInfo(cachedVal),cachedVal):function(store,state){return null!=executionInfo.latestLoadable&&null!=executionInfo.latestExecutionId&&!function(store,state){var _executionInfo$depVal,_mapOfCheckedVersions;const oldDepValues=null!==(_executionInfo$depVal=executionInfo.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==_executionInfo$depVal?_executionInfo$depVal:new Map,cachedDepValuesCheckedForThisVersion=Array((null!==(_mapOfCheckedVersions=mapOfCheckedVersions.get(state.version))&&void 0!==_mapOfCheckedVersions?_mapOfCheckedVersions:new Map).entries()),isCachedVersionSame=mapOfCheckedVersions.has(state.version)&&cachedDepValuesCheckedForThisVersion.length===oldDepValues.size&&cachedDepValuesCheckedForThisVersion.every(([nodeKey,nodeVal])=>oldDepValues.get(nodeKey)===nodeVal);if(null==oldDepValues||state.version===executionInfo.stateVersion||isCachedVersionSame)return!1;return mapOfCheckedVersions.set(state.version,new Map(oldDepValues)),Array.from(oldDepValues).some(([nodeKey,oldVal])=>{const[,loadable]=getCachedNodeLoadable(store,state,nodeKey);return loadable.contents!==oldVal.contents&&!("loading"===oldVal.state&&"loading"!==loadable.state)})}(store,state)}(store,state)?(notifyStoreWhenAsyncSettles(store,Recoil_nullthrows(executionInfo.latestLoadable),Recoil_nullthrows(executionInfo.latestExecutionId)),Recoil_nullthrows(executionInfo.latestLoadable)):getValFromRunningNewExecutionAndUpdatedDeps(store,state)}const mapOfCheckedVersions=new Map;function setExecutionInfo(loadable,depValues,newExecutionId,state){"loading"===loadable.state?(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues,executionInfo.latestExecutionId=newExecutionId,executionInfo.latestLoadable=loadable,executionInfo.stateVersion=null==state?void 0:state.version):(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=null,executionInfo.latestExecutionId=null,executionInfo.latestLoadable=null,executionInfo.stateVersion=null)}function updateExecutionInfoDepValues(depValues,executionId){isLatestExecution(executionId)&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}function isLatestExecution(executionId){return executionId===executionInfo.latestExecutionId}function maybeFreezeLoadableContents(loadable){"loading"!==loadable.state&&loadable.contents}function setCache(state,cacheRoute,loadable){state.atomValues.set(key,loadable),cache.set(cacheRoute,loadable)}function detectCircularDependencies(fn){if(dependencyStack.includes(key)){const message="Recoil selector has circular dependencies: "+dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ");return loadableWithError$1(new Error(message))}dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}function myPeek(store,state){return cache.get(nodeKey=>{const peek=peekNodeLoadable$2(store,state,nodeKey);return null==peek?void 0:peek.contents})}function myGet(store,state){return initSelector(store),[new Map,detectCircularDependencies(()=>getSelectorValAndUpdatedDeps(store,state))]}function invalidate(state){state.atomValues.delete(key)}if(null!=set){return registerNode$1({key:key,peek:myPeek,get:myGet,set:function(store,state,newValue){initSelector(store);const dependencyMap=new Map,writes=new Map;function getRecoilValue({key:key}){const[,loadable]=getCachedNodeLoadable(store,state,key);if("hasValue"===loadable.state)return loadable.contents;throw"loading"===loadable.state?new RecoilValueNotReady$2(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){const newValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater,[,upstreamWrites]=setNodeValue$3(store,state,recoilState.key,newValue);upstreamWrites.forEach((v,k)=>writes.set(k,v))}return set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$3)}},newValue),[dependencyMap,writes]},cleanUp:()=>{},invalidate:invalidate,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}return registerNode$1({key:key,peek:myPeek,get:myGet,cleanUp:()=>{},invalidate:invalidate,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})};const{loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$2}=Recoil_Loadable,{getNodeLoadable:getNodeLoadable$3,peekNodeLoadable:peekNodeLoadable$3,setNodeValue:setNodeValue$4}=Recoil_FunctionalCore,{addToDependencyMap:addToDependencyMap$1,mergeDepsIntoDependencyMap:mergeDepsIntoDependencyMap$1,saveDependencyMapToStore:saveDependencyMapToStore$4}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$4,RecoilValueNotReady:RecoilValueNotReady$3,registerNode:registerNode$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$4}=Recoil_RecoilValue$1,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$3,isRecoilValue:isRecoilValue$3,setRecoilValueLoadable:setRecoilValueLoadable$3}=Recoil_RecoilValueInterface,{startPerfBlock:startPerfBlock$2}=Recoil_PerformanceTimings,emptySet$2=Object.freeze(new Set);function cacheKeyFromDepValues(depValues){const answer=[];for(const key of Array.from(depValues.keys()).sort()){const loadable=Recoil_nullthrows(depValues.get(key));answer.push(key),answer.push(loadable.state),answer.push(loadable.contents)}return answer}const waitingStores$1=new Map;var Recoil_selector_OLD=function(options){const{key:key,get:get,cacheImplementation_UNSTABLE:cacheImplementation}=options,set=null!=options.set?options.set:void 0;let cache=null!=cacheImplementation?cacheImplementation:Recoil_cacheWithReferenceEquality();function initSelector(store){store.getState().knownSelectors.add(key)}function letStoreBeNotifiedWhenAsyncSettles(store,loadable){if("loading"===loadable.state){let stores=waitingStores$1.get(loadable);void 0===stores&&waitingStores$1.set(loadable,stores=new Set),stores.add(store)}}function notifyStoresOfSettledAsync(originalLoadable,newLoadable){const stores=waitingStores$1.get(originalLoadable);if(void 0!==stores){for(const store of stores)setRecoilValueLoadable$3(store,new AbstractRecoilValue$4(key),newLoadable);waitingStores$1.delete(originalLoadable)}}function getFromCacheOrEvaluate(store,state){var _store$getGraph$nodeD;const dependencyMap=new Map,currentDeps=null!==(_store$getGraph$nodeD=store.getGraph(state.version).nodeDeps.get(key))&&void 0!==_store$getGraph$nodeD?_store$getGraph$nodeD:emptySet$2,cacheKey=cacheKeyFromDepValues(new Map(Array.from(currentDeps).sort().map(depKey=>{const[deps,loadable]=getNodeLoadable$3(store,state,depKey);return mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$4(dependencyMap,store,state.version),[depKey,loadable]}))),cached=cache.get(cacheKey);if(null!=cached)return letStoreBeNotifiedWhenAsyncSettles(store,cached),[dependencyMap,cached];const[deps,loadable,newDepValues]=function(store,state){const endPerfBlock=startPerfBlock$2(key),depValues=new Map,dependencyMap=new Map;function getRecoilValue({key:depKey}){addToDependencyMap$1(key,depKey,dependencyMap);const[deps,loadable]=getNodeLoadable$3(store,state,depKey);if(depValues.set(depKey,loadable),mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$4(dependencyMap,store,state.version),"hasValue"===loadable.state)return loadable.contents;throw loadable.contents}try{const output=get({get:getRecoilValue}),result=isRecoilValue$3(output)?getRecoilValue(output):output;let loadable;return Recoil_isPromise(result)?loadable=loadableWithPromise$2(result.finally(endPerfBlock)):(endPerfBlock(),loadable=loadableWithValue$2(result)),[dependencyMap,loadable,depValues]}catch(errorOrDepPromise){let loadable;return void 0!==errorOrDepPromise.then?loadable=loadableWithPromise$2(errorOrDepPromise.then(()=>{const loadable=getRecoilValueAsLoadable$3(store,new AbstractRecoilValue$4(key));if("hasError"===loadable.state)throw loadable.contents;return loadable.contents}).finally(endPerfBlock)):(endPerfBlock(),loadable=loadableWithError$2(errorOrDepPromise)),[dependencyMap,loadable,depValues]}}(store,state);mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$4(dependencyMap,store,state.version);const newCacheKey=cacheKeyFromDepValues(newDepValues);return letStoreBeNotifiedWhenAsyncSettles(store,loadable),function(state,cacheKey,loadable){"loading"!==loadable.state||loadable.contents.then(result=>{const newLoadable=loadableWithValue$2(result);return cache=cache.set(cacheKey,newLoadable),notifyStoresOfSettledAsync(loadable,newLoadable),result}).catch(error=>{if(Recoil_isPromise(error))return error;const newLoadable=loadableWithError$2(error);return cache=cache.set(cacheKey,newLoadable),notifyStoresOfSettledAsync(loadable,newLoadable),error}),cache=cache.set(cacheKey,loadable),"loading"!==loadable.state&&state.atomValues.set(key,loadable)}(state,newCacheKey,loadable),[dependencyMap,loadable]}function myPeek(store,state){var _store$getGraph$nodeD2;const currentDeps=null!==(_store$getGraph$nodeD2=store.getGraph(state.version).nodeDeps.get(key))&&void 0!==_store$getGraph$nodeD2?_store$getGraph$nodeD2:emptySet$2,depValues=new Map(Array.from(currentDeps).sort().map(depKey=>[depKey,peekNodeLoadable$3(store,state,depKey)])),cacheDepValues=new Map;for(const[depKey,depValue]of depValues.entries()){if(null==depValue)return;cacheDepValues.set(depKey,depValue)}const cacheKey=cacheKeyFromDepValues(cacheDepValues);return cache.get(cacheKey)}function invalidate(state){state.atomValues.delete(key)}function myGet(store,state){initSelector(store);const cached=state.atomValues.get(key);return void 0!==cached?[new Map,cached]:getFromCacheOrEvaluate(store,state)}if(null!=set){return registerNode$2({key:key,peek:myPeek,get:myGet,set:function(store,state,newValue){initSelector(store);const dependencyMap=new Map,writes=new Map;function getRecoilValue({key:key}){const[deps,loadable]=getNodeLoadable$3(store,state,key);if(mergeDepsIntoDependencyMap$1(deps,dependencyMap),"hasValue"===loadable.state)return loadable.contents;throw"loading"===loadable.state?new RecoilValueNotReady$3(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){const newValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater,[deps,upstreamWrites]=setNodeValue$4(store,state,recoilState.key,newValue);mergeDepsIntoDependencyMap$1(deps,dependencyMap),upstreamWrites.forEach((v,k)=>writes.set(k,v))}return set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$4)}},newValue),[dependencyMap,writes]},invalidate:invalidate,cleanUp:()=>{},dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}return registerNode$2({key:key,peek:myPeek,get:myGet,invalidate:invalidate,cleanUp:()=>{},dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})};var Recoil_selector=Recoil_gkx_1("recoil_async_selector_refactor")?Recoil_selector_NEW:Recoil_selector_OLD;const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$3}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$5,DefaultValue:DefaultValue$2,registerNode:registerNode$3}=Recoil_Node,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1,setRecoilValue:setRecoilValue$3,setRecoilValueLoadable:setRecoilValueLoadable$4}=Recoil_RecoilValueInterface;function baseAtom(options){const{key:key,persistence_UNSTABLE:persistence}=options;let defaultLoadable=Recoil_isPromise(options.default)?loadableWithPromise$3(options.default.then(value=>{defaultLoadable=loadableWithValue$3(value);return{__key:key,__value:value}}).catch(error=>{throw defaultLoadable=loadableWithError$3(error),error})):loadableWithValue$3(options.default),cachedAnswerForUnvalidatedValue=void 0;const cleanupEffectsByStore=new Map;function initAtom(store,initState,trigger){if(store.getState().knownAtoms.has(key))return;if(store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){function notifyDefaultSubscribers(){var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$1(store,node)}defaultLoadable.contents.then(notifyDefaultSubscribers).catch(notifyDefaultSubscribers)}let initValue=DEFAULT_VALUE$5,pendingSetSelf=null;if(null!=options.effects_UNSTABLE){let duringInit=!0;const setSelf=effect=>valueOrUpdater=>{if(duringInit){const currentValue=initValue instanceof DefaultValue$2||Recoil_isPromise(initValue)?"hasValue"===defaultLoadable.state?defaultLoadable.contents:DEFAULT_VALUE$5:initValue;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater}else{if(Recoil_isPromise(valueOrUpdater))throw new Error("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect:effect,value:valueOrUpdater}),setRecoilValue$3(store,node,"function"==typeof valueOrUpdater?currentValue=>{const newValue=valueOrUpdater(currentValue);return pendingSetSelf={effect:effect,value:newValue},newValue}:valueOrUpdater)}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$5),onSet=effect=>handler=>{store.subscribeToTransactions(currentStore=>{var _pendingSetSelf3;let{currentTree:currentTree,previousTree:previousTree}=currentStore.getState();previousTree||(previousTree=currentTree);const newLoadable=currentTree.atomValues.get(key);if(null==newLoadable||"hasValue"===newLoadable.state){var _previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2;const newValue=null!=newLoadable?newLoadable.contents:DEFAULT_VALUE$5,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$5;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)===effect&&(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)===newValue||handler(newValue,oldValue)}(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)},key)};for(const effect of null!==(_options$effects_UNST=options.effects_UNSTABLE)&&void 0!==_options$effects_UNST?_options$effects_UNST:[]){var _options$effects_UNST;const cleanup=effect({node:node,trigger:trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect)});null!=cleanup&&cleanupEffectsByStore.set(store,cleanup)}duringInit=!1}initValue instanceof DefaultValue$2||initState.atomValues.set(key,Recoil_isPromise(initValue)?loadableWithPromise$3(function(store,promise){const wrappedPromise=promise.then(value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$3(store,node,value),{__key:key,__value:value}}).catch(error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$4(store,node,loadableWithError$3(error)),error});return wrappedPromise}(store,initValue)):loadableWithValue$3(initValue))}const node=registerNode$3({key:key,peek:function(_store,state){var _ref,_state$atomValues$get3,_cachedAnswerForUnval;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:null===(_cachedAnswerForUnval=cachedAnswerForUnvalidatedValue)||void 0===_cachedAnswerForUnval?void 0:_cachedAnswerForUnval[1])&&void 0!==_ref?_ref:defaultLoadable},get:function(store,state){if(initAtom(store,state,"get"),state.atomValues.has(key))return[new Map,Recoil_nullthrows(state.atomValues.get(key))];if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return[new Map,defaultLoadable];const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$5),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$3(validatorResult);return cachedAnswerForUnvalidatedValue=[new Map,validatedValueLoadable],cachedAnswerForUnvalidatedValue}return[new Map,defaultLoadable]},set:function(store,state,newValue){if(initAtom(store,state,"set"),state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return[new Map,new Map]}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return[new Map,new Map];return cachedAnswerForUnvalidatedValue=void 0,[new Map,(new Map).set(key,loadableWithValue$3(newValue))]},cleanUp:function(store){var _cleanupEffectsByStor;null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor(),cleanupEffectsByStore.delete(store)},invalidate:function(){cachedAnswerForUnvalidatedValue=void 0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0});return node}function atom(options){const{default:optionsDefault,...restOptions}=options;return isRecoilValue$4(optionsDefault)?function(options){const base=atom({...options,default:DEFAULT_VALUE$5,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$5)},effects_UNSTABLE:options.effects_UNSTABLE});return Recoil_selector({key:options.key+"__withFallback",get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),dangerouslyAllowMutability:options.dangerouslyAllowMutability})}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}var Recoil_atom=atom;let nextIndex=0;var Recoil_selectorFamily=function(options){var _options$cacheImpleme,_options$cacheImpleme2;let selectorCache=null!==(_options$cacheImpleme=null===(_options$cacheImpleme2=options.cacheImplementationForParams_UNSTABLE)||void 0===_options$cacheImpleme2?void 0:_options$cacheImpleme2.call(options))&&void 0!==_options$cacheImpleme?_options$cacheImpleme:Recoil_cacheWithValueEquality();return params=>{var _stableStringify,_options$cacheImpleme3;const cachedSelector=selectorCache.get(params);if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCacheImplementation=null===(_options$cacheImpleme3=options.cacheImplementation_UNSTABLE)||void 0===_options$cacheImpleme3?void 0:_options$cacheImpleme3.call(options);let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability})}else newSelector=Recoil_selector({key:myKey,get:myGet,cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability});return selectorCache=selectorCache.set(params,newSelector),newSelector}};const{DEFAULT_VALUE:DEFAULT_VALUE$6,DefaultValue:DefaultValue$3}=Recoil_Node;var Recoil_atomFamily=function(options){let atomCache=Recoil_cacheWithValueEquality();const legacyAtomOptions={key:options.key,default:DEFAULT_VALUE$6,persistence_UNSTABLE:options.persistence_UNSTABLE};let legacyAtom;legacyAtom=Recoil_atom(legacyAtomOptions);const atomFamilyDefault=Recoil_selectorFamily({key:options.key+"__atomFamily/Default",get:param=>({get:get})=>{const legacyValue=get("function"==typeof legacyAtom?legacyAtom(param):legacyAtom);return legacyValue instanceof DefaultValue$3?"function"==typeof options.default?options.default(param):options.default:legacyValue},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return params=>{var _stableStringify;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const newAtom=Recoil_atom({...options,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:atomFamilyDefault(params),effects_UNSTABLE:"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):options.effects_UNSTABLE});return atomCache=atomCache.set(params,newAtom),newAtom}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_constSelector=function(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw new Error(message)},cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_errorSelector=function(message){return throwingSelector(message)};var Recoil_readOnlySelector=function(atom){return atom};const{loadableWithError:loadableWithError$4,loadableWithPromise:loadableWithPromise$4,loadableWithValue:loadableWithValue$4}=Recoil_Loadable;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function getValueFromLoadablePromiseResult(result){return null!=result&&"object"==typeof result&&result.hasOwnProperty("__value")?result.__value:result}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$4(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$4(exception):loadableWithError$4(exception)))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)}}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.some(exp=>null==exp))return wrapLoadables(dependencies,results,exceptions);if(exceptions.every(isError))throw exceptions.find(isError);if(Recoil_gkx_1("recoil_async_selector_refactor"))return new Promise((resolve,reject)=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=null,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,exceptions.every(isError)&&reject(exceptions[0])})});throw new Promise((resolve,reject)=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=result,exceptions[i]=null,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,exceptions.every(isError)&&reject(exceptions[0])})})}}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;if(Recoil_gkx_1("recoil_async_selector_refactor"))return Promise.all(exceptions).then(exceptionResults=>{return wrapResults(dependencies,(syncResults=results,asyncResults=exceptionResults,asyncResults.map((result,idx)=>void 0===result?syncResults[idx]:result)).map(getValueFromLoadablePromiseResult));var syncResults,asyncResults});throw Promise.all(exceptions).then(results=>wrapResults(dependencies,results))}}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get:get})=>{try{return loadableWithValue$4(get(dependency))}catch(exception){return Recoil_isPromise(exception)?loadableWithPromise$4(exception):loadableWithError$4(exception)}}})};const{batchUpdates:batchUpdates$3,setBatcher:setBatcher$1}=Recoil_Batching,{DefaultValue:DefaultValue$4}=Recoil_Node,{RecoilRoot:RecoilRoot$2}=Recoil_RecoilRoot_react,{isRecoilValue:isRecoilValue$5}=Recoil_RecoilValue$1,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilCallback:useRecoilCallback$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1,useSetUnvalidatedAtomValues:useSetUnvalidatedAtomValues$1,useTransactionObservation_DEPRECATED:useTransactionObservation_DEPRECATED$1}=Recoil_Hooks,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$4,RecoilRoot:RecoilRoot$2,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useRecoilCallback:useRecoilCallback$1,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,useTransactionObservation_UNSTABLE:useTransactionObservation_DEPRECATED$1,useSetUnvalidatedAtomValues_UNSTABLE:useSetUnvalidatedAtomValues$1,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,isRecoilValue:isRecoilValue$5,batchUpdates:batchUpdates$3,setBatcher:setBatcher$1,snapshot_UNSTABLE:freshSnapshot$2},Recoil_index_1=Recoil_index.DefaultValue,Recoil_index_2=Recoil_index.RecoilRoot,Recoil_index_3=Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_4=Recoil_index.atom,Recoil_index_5=Recoil_index.selector,Recoil_index_6=Recoil_index.atomFamily,Recoil_index_7=Recoil_index.selectorFamily,Recoil_index_8=Recoil_index.constSelector,Recoil_index_9=Recoil_index.errorSelector,Recoil_index_10=Recoil_index.readOnlySelector,Recoil_index_11=Recoil_index.useRecoilValue,Recoil_index_12=Recoil_index.useRecoilValueLoadable,Recoil_index_13=Recoil_index.useRecoilState,Recoil_index_14=Recoil_index.useRecoilStateLoadable,Recoil_index_15=Recoil_index.useSetRecoilState,Recoil_index_16=Recoil_index.useResetRecoilState,Recoil_index_17=Recoil_index.useRecoilCallback,Recoil_index_18=Recoil_index.useGotoRecoilSnapshot,Recoil_index_19=Recoil_index.useRecoilSnapshot,Recoil_index_20=Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index_21=Recoil_index.useTransactionObservation_UNSTABLE,Recoil_index_22=Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_23=Recoil_index.noWait,Recoil_index_24=Recoil_index.waitForNone,Recoil_index_25=Recoil_index.waitForAny,Recoil_index_26=Recoil_index.waitForAll,Recoil_index_27=Recoil_index.isRecoilValue,Recoil_index_28=Recoil_index.batchUpdates,Recoil_index_29=Recoil_index.setBatcher,Recoil_index_30=Recoil_index.snapshot_UNSTABLE;exports.DefaultValue=Recoil_index_1,exports.RecoilRoot=Recoil_index_2,exports.atom=Recoil_index_4,exports.atomFamily=Recoil_index_6,exports.batchUpdates=Recoil_index_28,exports.constSelector=Recoil_index_8,exports.default=Recoil_index,exports.errorSelector=Recoil_index_9,exports.isRecoilValue=Recoil_index_27,exports.noWait=Recoil_index_23,exports.readOnlySelector=Recoil_index_10,exports.selector=Recoil_index_5,exports.selectorFamily=Recoil_index_7,exports.setBatcher=Recoil_index_29,exports.snapshot_UNSTABLE=Recoil_index_30,exports.useGotoRecoilSnapshot=Recoil_index_18,exports.useRecoilBridgeAcrossReactRoots_UNSTABLE=Recoil_index_3,exports.useRecoilCallback=Recoil_index_17,exports.useRecoilSnapshot=Recoil_index_19,exports.useRecoilState=Recoil_index_13,exports.useRecoilStateLoadable=Recoil_index_14,exports.useRecoilTransactionObserver_UNSTABLE=Recoil_index_20,exports.useRecoilValue=Recoil_index_11,exports.useRecoilValueLoadable=Recoil_index_12,exports.useResetRecoilState=Recoil_index_16,exports.useSetRecoilState=Recoil_index_15,exports.useSetUnvalidatedAtomValues_UNSTABLE=Recoil_index_22,exports.useTransactionObservation_UNSTABLE=Recoil_index_21,exports.waitForAll=Recoil_index_26,exports.waitForAny=Recoil_index_25,exports.waitForNone=Recoil_index_24,Object.defineProperty(exports,"__esModule",{value:!0})}));
