{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Coin = void 0;\n\nvar json_1 = require(\"../util/json\");\n\nvar numeric_1 = require(\"./numeric\");\n/**\n * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines\n * a denomination with an amount value. Coins are immutable once created, and operations\n * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.\n */\n\n\nvar Coin =\n/** @class */\nfunction (_super) {\n  __extends(Coin, _super);\n  /**\n   * Creates a new coin. Depending on the type of amount, it will be converted to an\n   * integer coin or decimal coin.\n   *\n   * @param denom denomination\n   * @param amount coin's amount\n   */\n\n\n  function Coin(denom, amount) {\n    var _this = _super.call(this) || this;\n\n    _this.denom = denom;\n    _this.amount = numeric_1.Numeric.parse(amount);\n    return _this;\n  }\n\n  Coin.fromData = function (data) {\n    var denom = data.denom,\n        amount = data.amount;\n    return new Coin(denom, amount);\n  };\n  /**\n   * Checks whether the Coin is an Integer coin.\n   */\n\n\n  Coin.prototype.isIntCoin = function () {\n    // TODO: convert into typeguard\n    return this.amount instanceof numeric_1.Int;\n  };\n  /**\n   * Checks whether the Coin is a Decimal coin.\n   */\n\n\n  Coin.prototype.isDecCoin = function () {\n    return this.amount instanceof numeric_1.Dec;\n  };\n  /**\n   * Turns the Coin into an Integer coin.\n   */\n\n\n  Coin.prototype.toIntCoin = function () {\n    return new Coin(this.denom, new numeric_1.Int(this.amount));\n  };\n  /**\n   * Turns the Coin into a Decimal coin.\n   */\n\n\n  Coin.prototype.toDecCoin = function () {\n    return new Coin(this.denom, new numeric_1.Dec(this.amount));\n  };\n\n  Coin.prototype.toData = function () {\n    var _a = this,\n        denom = _a.denom,\n        amount = _a.amount;\n\n    return {\n      denom: denom,\n      amount: amount.toString()\n    };\n  };\n  /**\n   * Outputs `<amount><denom>`.\n   *\n   * Eg: `Coin('uluna', 1500) -> 1500uluna`\n   */\n\n\n  Coin.prototype.toString = function () {\n    var amount = this.amount.toFixed();\n\n    if (this.isDecCoin() && amount.indexOf('.') === -1) {\n      return amount + \".0\" + this.denom;\n    }\n\n    return \"\" + amount + this.denom;\n  };\n\n  Coin.fromString = function (str) {\n    var m = str.match(/^(-?[0-9]+(\\.[0-9]+)?)([a-zA-Z]+)$/);\n\n    if (m === null) {\n      throw new Error(\"failed to parse to Coin: \" + str);\n    }\n\n    var amount = m[1];\n    var denom = m[3];\n    return new Coin(denom, amount);\n  };\n  /**\n   * Creates a new Coin adding to the current value.\n   *\n   * @param other\n   */\n\n\n  Coin.prototype.add = function (other) {\n    var otherAmount;\n\n    if (other instanceof Coin) {\n      if (other.denom !== this.denom) {\n        throw new Coin.ArithmeticError(\"cannot add two Coins of different denoms: \" + this.denom + \" and \" + other.denom);\n      }\n\n      otherAmount = other.amount;\n    } else {\n      otherAmount = other;\n    }\n\n    otherAmount = numeric_1.Numeric.parse(otherAmount);\n    return new Coin(this.denom, this.amount.add(otherAmount));\n  };\n  /**\n   * Creates a new Coin subtracting from the current value.\n   * @param other\n   */\n\n\n  Coin.prototype.sub = function (other) {\n    var otherAmount;\n\n    if (other instanceof Coin) {\n      if (other.denom !== this.denom) {\n        throw new Coin.ArithmeticError(\"cannot subtract two Coins of different denoms: \" + this.denom + \" and \" + other.denom);\n      }\n\n      otherAmount = other.amount;\n    } else {\n      otherAmount = other;\n    }\n\n    otherAmount = numeric_1.Numeric.parse(otherAmount);\n    return new Coin(this.denom, this.amount.sub(otherAmount));\n  };\n  /**\n   * Multiplies the current value with an amount.\n   * @param other\n   */\n\n\n  Coin.prototype.mul = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.mul(otherAmount));\n  };\n  /**\n   * Divides the current value with an amount.\n   * @param other\n   */\n\n\n  Coin.prototype.div = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.div(otherAmount));\n  };\n  /**\n   * Modulo the current value with an amount.\n   * @param other\n   */\n\n\n  Coin.prototype.mod = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.mod(otherAmount));\n  };\n\n  return Coin;\n}(json_1.JSONSerializable);\n\nexports.Coin = Coin;\n\n(function (Coin) {\n  var ArithmeticError =\n  /** @class */\n  function () {\n    function ArithmeticError(message) {\n      this.message = message;\n    }\n\n    return ArithmeticError;\n  }();\n\n  Coin.ArithmeticError = ArithmeticError;\n})(Coin = exports.Coin || (exports.Coin = {}));\n\nexports.Coin = Coin;","map":{"version":3,"sources":["../../src/core/Coin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Coin = void 0;\nvar json_1 = require(\"../util/json\");\nvar numeric_1 = require(\"./numeric\");\n/**\n * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines\n * a denomination with an amount value. Coins are immutable once created, and operations\n * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.\n */\nvar Coin = /** @class */ (function (_super) {\n    __extends(Coin, _super);\n    /**\n     * Creates a new coin. Depending on the type of amount, it will be converted to an\n     * integer coin or decimal coin.\n     *\n     * @param denom denomination\n     * @param amount coin's amount\n     */\n    function Coin(denom, amount) {\n        var _this = _super.call(this) || this;\n        _this.denom = denom;\n        _this.amount = numeric_1.Numeric.parse(amount);\n        return _this;\n    }\n    Coin.fromData = function (data) {\n        var denom = data.denom, amount = data.amount;\n        return new Coin(denom, amount);\n    };\n    /**\n     * Checks whether the Coin is an Integer coin.\n     */\n    Coin.prototype.isIntCoin = function () {\n        // TODO: convert into typeguard\n        return this.amount instanceof numeric_1.Int;\n    };\n    /**\n     * Checks whether the Coin is a Decimal coin.\n     */\n    Coin.prototype.isDecCoin = function () {\n        return this.amount instanceof numeric_1.Dec;\n    };\n    /**\n     * Turns the Coin into an Integer coin.\n     */\n    Coin.prototype.toIntCoin = function () {\n        return new Coin(this.denom, new numeric_1.Int(this.amount));\n    };\n    /**\n     * Turns the Coin into a Decimal coin.\n     */\n    Coin.prototype.toDecCoin = function () {\n        return new Coin(this.denom, new numeric_1.Dec(this.amount));\n    };\n    Coin.prototype.toData = function () {\n        var _a = this, denom = _a.denom, amount = _a.amount;\n        return {\n            denom: denom,\n            amount: amount.toString(),\n        };\n    };\n    /**\n     * Outputs `<amount><denom>`.\n     *\n     * Eg: `Coin('uluna', 1500) -> 1500uluna`\n     */\n    Coin.prototype.toString = function () {\n        var amount = this.amount.toFixed();\n        if (this.isDecCoin() && amount.indexOf('.') === -1) {\n            return amount + \".0\" + this.denom;\n        }\n        return \"\" + amount + this.denom;\n    };\n    Coin.fromString = function (str) {\n        var m = str.match(/^(-?[0-9]+(\\.[0-9]+)?)([a-zA-Z]+)$/);\n        if (m === null) {\n            throw new Error(\"failed to parse to Coin: \" + str);\n        }\n        var amount = m[1];\n        var denom = m[3];\n        return new Coin(denom, amount);\n    };\n    /**\n     * Creates a new Coin adding to the current value.\n     *\n     * @param other\n     */\n    Coin.prototype.add = function (other) {\n        var otherAmount;\n        if (other instanceof Coin) {\n            if (other.denom !== this.denom) {\n                throw new Coin.ArithmeticError(\"cannot add two Coins of different denoms: \" + this.denom + \" and \" + other.denom);\n            }\n            otherAmount = other.amount;\n        }\n        else {\n            otherAmount = other;\n        }\n        otherAmount = numeric_1.Numeric.parse(otherAmount);\n        return new Coin(this.denom, this.amount.add(otherAmount));\n    };\n    /**\n     * Creates a new Coin subtracting from the current value.\n     * @param other\n     */\n    Coin.prototype.sub = function (other) {\n        var otherAmount;\n        if (other instanceof Coin) {\n            if (other.denom !== this.denom) {\n                throw new Coin.ArithmeticError(\"cannot subtract two Coins of different denoms: \" + this.denom + \" and \" + other.denom);\n            }\n            otherAmount = other.amount;\n        }\n        else {\n            otherAmount = other;\n        }\n        otherAmount = numeric_1.Numeric.parse(otherAmount);\n        return new Coin(this.denom, this.amount.sub(otherAmount));\n    };\n    /**\n     * Multiplies the current value with an amount.\n     * @param other\n     */\n    Coin.prototype.mul = function (other) {\n        var otherAmount = numeric_1.Numeric.parse(other);\n        return new Coin(this.denom, this.amount.mul(otherAmount));\n    };\n    /**\n     * Divides the current value with an amount.\n     * @param other\n     */\n    Coin.prototype.div = function (other) {\n        var otherAmount = numeric_1.Numeric.parse(other);\n        return new Coin(this.denom, this.amount.div(otherAmount));\n    };\n    /**\n     * Modulo the current value with an amount.\n     * @param other\n     */\n    Coin.prototype.mod = function (other) {\n        var otherAmount = numeric_1.Numeric.parse(other);\n        return new Coin(this.denom, this.amount.mod(otherAmount));\n    };\n    return Coin;\n}(json_1.JSONSerializable));\nexports.Coin = Coin;\n(function (Coin) {\n    var ArithmeticError = /** @class */ (function () {\n        function ArithmeticError(message) {\n            this.message = message;\n        }\n        return ArithmeticError;\n    }());\n    Coin.ArithmeticError = ArithmeticError;\n})(Coin = exports.Coin || (exports.Coin = {}));\nexports.Coin = Coin;\n//# sourceMappingURL=Coin.js.map"]},"metadata":{},"sourceType":"script"}