{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PolicyConstraints = void 0;\n\nvar json_1 = require(\"../../util/json\");\n\nvar Coin_1 = require(\"../Coin\");\n\nvar numeric_1 = require(\"../numeric\");\n/**\n * This captures the Treasury module's `tax_policy` and `reward_policy` parameters, which\n * determine how the Tax Rate and Reward Weight values are allowed to change.\n */\n\n\nvar PolicyConstraints =\n/** @class */\nfunction (_super) {\n  __extends(PolicyConstraints, _super);\n  /**\n   *\n   * @param rate_min minimum value\n   * @param rate_max maximum value\n   * @param cap Tax Cap (only applicable for Tax Rate)\n   * @param change_max max change %\n   */\n\n\n  function PolicyConstraints(rate_min, rate_max, cap, change_max) {\n    var _this = _super.call(this) || this;\n\n    _this.cap = cap;\n    _this.rate_min = new numeric_1.Dec(rate_min);\n    _this.rate_max = new numeric_1.Dec(rate_max);\n    _this.change_max = new numeric_1.Dec(change_max);\n    return _this;\n  }\n\n  PolicyConstraints.fromData = function (data) {\n    var rate_min = data.rate_min,\n        rate_max = data.rate_max,\n        cap = data.cap,\n        change_max = data.change_max;\n    return new PolicyConstraints(rate_min, rate_max, Coin_1.Coin.fromData(cap), change_max);\n  };\n\n  PolicyConstraints.prototype.toData = function () {\n    var _a = this,\n        rate_min = _a.rate_min,\n        rate_max = _a.rate_max,\n        cap = _a.cap,\n        change_max = _a.change_max;\n\n    return {\n      rate_min: rate_min.toString(),\n      rate_max: rate_max.toString(),\n      cap: cap.toData(),\n      change_max: change_max.toString()\n    };\n  };\n  /**\n   * You can simulate the result of the clamping algorithm, which subjects updates in\n   * rate to the rules defined by the `PolicyConstraints`.\n   *\n   * @param prevRate previous rate\n   * @param newRate next rate\n   * @returns New rate, after clamping constraints have been applied\n   */\n\n\n  PolicyConstraints.prototype.clamp = function (prevRate, newRate) {\n    var p = new numeric_1.Dec(prevRate); // prev\n\n    var n = new numeric_1.Dec(newRate); // new\n\n    if (n.lt(this.rate_min)) {\n      n = this.rate_min;\n    } else if (n.gt(this.rate_max)) {\n      n = this.rate_max;\n    }\n\n    var delta = n.sub(p);\n\n    if (n.gt(p)) {\n      if (delta.gt(this.change_max)) {\n        n = p.add(this.change_max);\n      }\n    } else {\n      if (delta.abs().gt(this.change_max)) {\n        n = p.sub(this.change_max);\n      }\n    }\n\n    return n;\n  };\n\n  return PolicyConstraints;\n}(json_1.JSONSerializable);\n\nexports.PolicyConstraints = PolicyConstraints;","map":{"version":3,"sources":["../../../src/core/treasury/PolicyConstraints.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PolicyConstraints = void 0;\nvar json_1 = require(\"../../util/json\");\nvar Coin_1 = require(\"../Coin\");\nvar numeric_1 = require(\"../numeric\");\n/**\n * This captures the Treasury module's `tax_policy` and `reward_policy` parameters, which\n * determine how the Tax Rate and Reward Weight values are allowed to change.\n */\nvar PolicyConstraints = /** @class */ (function (_super) {\n    __extends(PolicyConstraints, _super);\n    /**\n     *\n     * @param rate_min minimum value\n     * @param rate_max maximum value\n     * @param cap Tax Cap (only applicable for Tax Rate)\n     * @param change_max max change %\n     */\n    function PolicyConstraints(rate_min, rate_max, cap, change_max) {\n        var _this = _super.call(this) || this;\n        _this.cap = cap;\n        _this.rate_min = new numeric_1.Dec(rate_min);\n        _this.rate_max = new numeric_1.Dec(rate_max);\n        _this.change_max = new numeric_1.Dec(change_max);\n        return _this;\n    }\n    PolicyConstraints.fromData = function (data) {\n        var rate_min = data.rate_min, rate_max = data.rate_max, cap = data.cap, change_max = data.change_max;\n        return new PolicyConstraints(rate_min, rate_max, Coin_1.Coin.fromData(cap), change_max);\n    };\n    PolicyConstraints.prototype.toData = function () {\n        var _a = this, rate_min = _a.rate_min, rate_max = _a.rate_max, cap = _a.cap, change_max = _a.change_max;\n        return {\n            rate_min: rate_min.toString(),\n            rate_max: rate_max.toString(),\n            cap: cap.toData(),\n            change_max: change_max.toString(),\n        };\n    };\n    /**\n     * You can simulate the result of the clamping algorithm, which subjects updates in\n     * rate to the rules defined by the `PolicyConstraints`.\n     *\n     * @param prevRate previous rate\n     * @param newRate next rate\n     * @returns New rate, after clamping constraints have been applied\n     */\n    PolicyConstraints.prototype.clamp = function (prevRate, newRate) {\n        var p = new numeric_1.Dec(prevRate); // prev\n        var n = new numeric_1.Dec(newRate); // new\n        if (n.lt(this.rate_min)) {\n            n = this.rate_min;\n        }\n        else if (n.gt(this.rate_max)) {\n            n = this.rate_max;\n        }\n        var delta = n.sub(p);\n        if (n.gt(p)) {\n            if (delta.gt(this.change_max)) {\n                n = p.add(this.change_max);\n            }\n        }\n        else {\n            if (delta.abs().gt(this.change_max)) {\n                n = p.sub(this.change_max);\n            }\n        }\n        return n;\n    };\n    return PolicyConstraints;\n}(json_1.JSONSerializable));\nexports.PolicyConstraints = PolicyConstraints;\n//# sourceMappingURL=PolicyConstraints.js.map"]},"metadata":{},"sourceType":"script"}