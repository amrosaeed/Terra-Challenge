{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n\n      return true;\n    });\n  }\n\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return value !== null && typeof value === \"object\" && !isReference(value) && !Array.isArray(value);\n}\nexport function isFieldValueToBeMerged(value) {\n  var field = value && value.__field;\n  return field && isField(field);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger(reconcileProcessedFields);\n}\n\nvar reconcileProcessedFields = function reconcileProcessedFields(existingObject, incomingObject, property) {\n  var existing = existingObject[property];\n  var incoming = incomingObject[property];\n\n  if (isFieldValueToBeMerged(existing)) {\n    existing.__value = this.merge(existing.__value, isFieldValueToBeMerged(incoming) ? incoming.__value : incoming);\n    return existing;\n  }\n\n  if (isFieldValueToBeMerged(incoming)) {\n    incoming.__value = this.merge(existing, incoming.__value);\n    return incoming;\n  }\n\n  return this.merge(existing, incoming);\n};","map":{"version":3,"sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { FieldNode, SelectionSetNode } from 'graphql';\n\nimport { NormalizedCache } from './types';\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  ReconcilerFunction,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../../utilities';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\n// Invoking merge functions needs to happen after processSelectionSet has\n// finished, but requires information that is more readily available\n// during processSelectionSet, so processSelectionSet embeds special\n// objects of the following shape within its result tree, which then must\n// be removed by calling Policies#applyMerges.\nexport interface FieldValueToBeMerged {\n  __field: FieldNode;\n  __typename: string;\n  __value: StoreValue;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return value !== null &&\n    typeof value === \"object\" &&\n    !isReference(value) &&\n    !Array.isArray(value);\n}\n\nexport function isFieldValueToBeMerged(\n  value: any,\n): value is FieldValueToBeMerged {\n  const field = value && value.__field;\n  return field && isField(field);\n}\n\nexport function makeProcessedFieldsMerger() {\n  // A DeepMerger that merges arrays and objects structurally, but otherwise\n  // prefers incoming scalar values over existing values. Provides special\n  // treatment for FieldValueToBeMerged objects. Used to accumulate fields\n  // when processing a single selection set.\n  return new DeepMerger(reconcileProcessedFields);\n}\n\nconst reconcileProcessedFields: ReconcilerFunction<[]> = function (\n  existingObject,\n  incomingObject,\n  property,\n) {\n  const existing = existingObject[property];\n  const incoming = incomingObject[property];\n\n  if (isFieldValueToBeMerged(existing)) {\n    existing.__value = this.merge(\n      existing.__value,\n      isFieldValueToBeMerged(incoming)\n        // TODO Check compatibility of __field and __typename properties?\n        ? incoming.__value\n        : incoming,\n    );\n    return existing;\n  }\n\n  if (isFieldValueToBeMerged(incoming)) {\n    incoming.__value = this.merge(\n      existing,\n      incoming.__value,\n    );\n    return incoming;\n  }\n\n  return this.merge(existing, incoming);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}