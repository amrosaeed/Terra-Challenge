{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/amro/MirrorProtocol/eth-web-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/amro/MirrorProtocol/eth-web-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto = require(\"./crypto\");\n\nvar bs58check = require('bs58check');\n\nvar ecc = require('tiny-secp256k1');\n\nvar typeforce = require('typeforce');\n\nvar wif = require('wif');\n\nvar UINT256_TYPE = typeforce.BufferN(32);\nvar NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n});\nvar BITCOIN = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nvar HIGHEST_BIT = 0x80000000;\nvar UINT31_MAX = Math.pow(2, 31) - 1;\n\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null;\n}\n\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\n\nvar BIP32 = /*#__PURE__*/function () {\n  function BIP32(__D, __Q, chainCode, network) {\n    var __DEPTH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    var __INDEX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    var __PARENT_FINGERPRINT = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0x00000000;\n\n    _classCallCheck(this, BIP32);\n\n    this.__D = __D;\n    this.__Q = __Q;\n    this.chainCode = chainCode;\n    this.network = network;\n    this.__DEPTH = __DEPTH;\n    this.__INDEX = __INDEX;\n    this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n    typeforce(NETWORK_TYPE, network);\n    this.lowR = false;\n  }\n\n  _createClass(BIP32, [{\n    key: \"isNeutered\",\n    // Private === not neutered\n    // Public === neutered\n    value: function isNeutered() {\n      return this.__D === undefined;\n    }\n  }, {\n    key: \"neutered\",\n    value: function neutered() {\n      return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n  }, {\n    key: \"toBase58\",\n    value: function toBase58() {\n      var network = this.network;\n      var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n      var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n      buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n      buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n      buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n      // This is encoded in big endian. (0x00000000 if master key)\n\n      buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n      this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n      if (!this.isNeutered()) {\n        // 0x00 + k for private keys\n        buffer.writeUInt8(0, 45);\n        this.privateKey.copy(buffer, 46); // 33 bytes: the public key\n      } else {\n        // X9.62 encoding for public keys\n        this.publicKey.copy(buffer, 45);\n      }\n\n      return bs58check.encode(buffer);\n    }\n  }, {\n    key: \"toWIF\",\n    value: function toWIF() {\n      if (!this.privateKey) throw new TypeError('Missing private key');\n      return wif.encode(this.network.wif, this.privateKey, true);\n    } // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n  }, {\n    key: \"derive\",\n    value: function derive(index) {\n      typeforce(typeforce.UInt32, index);\n      var isHardened = index >= HIGHEST_BIT;\n      var data = Buffer.allocUnsafe(37); // Hardened child\n\n      if (isHardened) {\n        if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n        data[0] = 0x00;\n        this.privateKey.copy(data, 1);\n        data.writeUInt32BE(index, 33); // Normal child\n      } else {\n        // data = serP(point(kpar)) || ser32(index)\n        //      = serP(Kpar) || ser32(index)\n        this.publicKey.copy(data, 0);\n        data.writeUInt32BE(index, 33);\n      }\n\n      var I = crypto.hmacSHA512(this.chainCode, data);\n      var IL = I.slice(0, 32);\n      var IR = I.slice(32); // if parse256(IL) >= n, proceed with the next value for i\n\n      if (!ecc.isPrivate(IL)) return this.derive(index + 1); // Private parent key -> private child key\n\n      var hd;\n\n      if (!this.isNeutered()) {\n        // ki = parse256(IL) + kpar (mod n)\n        var ki = ecc.privateAdd(this.privateKey, IL); // In case ki == 0, proceed with the next value for i\n\n        if (ki == null) return this.derive(index + 1);\n        hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0)); // Public parent key -> public child key\n      } else {\n        // Ki = point(parse256(IL)) + Kpar\n        //    = G*IL + Kpar\n        var Ki = ecc.pointAddScalar(this.publicKey, IL, true); // In case Ki is the point at infinity, proceed with the next value for i\n\n        if (Ki === null) return this.derive(index + 1);\n        hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n      }\n\n      return hd;\n    }\n  }, {\n    key: \"deriveHardened\",\n    value: function deriveHardened(index) {\n      typeforce(UInt31, index); // Only derives hardened private keys by default\n\n      return this.derive(index + HIGHEST_BIT);\n    }\n  }, {\n    key: \"derivePath\",\n    value: function derivePath(path) {\n      typeforce(BIP32Path, path);\n      var splitPath = path.split('/');\n\n      if (splitPath[0] === 'm') {\n        if (this.parentFingerprint) throw new TypeError('Expected master, got child');\n        splitPath = splitPath.slice(1);\n      }\n\n      return splitPath.reduce(function (prevHd, indexStr) {\n        var index;\n\n        if (indexStr.slice(-1) === \"'\") {\n          index = parseInt(indexStr.slice(0, -1), 10);\n          return prevHd.deriveHardened(index);\n        } else {\n          index = parseInt(indexStr, 10);\n          return prevHd.derive(index);\n        }\n      }, this);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(hash, lowR) {\n      if (!this.privateKey) throw new Error('Missing private key');\n      if (lowR === undefined) lowR = this.lowR;\n\n      if (lowR === false) {\n        return ecc.sign(hash, this.privateKey);\n      } else {\n        var sig = ecc.sign(hash, this.privateKey);\n        var extraData = Buffer.alloc(32, 0);\n        var counter = 0; // if first try is lowR, skip the loop\n        // for second try and on, add extra entropy counting up\n\n        while (sig[0] > 0x7f) {\n          counter++;\n          extraData.writeUIntLE(counter, 0, 6);\n          sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n        }\n\n        return sig;\n      }\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(hash, signature) {\n      return ecc.verify(hash, this.publicKey, signature);\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.__DEPTH;\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.__INDEX;\n    }\n  }, {\n    key: \"parentFingerprint\",\n    get: function get() {\n      return this.__PARENT_FINGERPRINT;\n    }\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);\n      return this.__Q;\n    }\n  }, {\n    key: \"privateKey\",\n    get: function get() {\n      return this.__D;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return crypto.hash160(this.publicKey);\n    }\n  }, {\n    key: \"fingerprint\",\n    get: function get() {\n      return this.identifier.slice(0, 4);\n    }\n  }, {\n    key: \"compressed\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return BIP32;\n}();\n\nfunction fromBase58(inString, network) {\n  var buffer = bs58check.decode(inString);\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length');\n  network = network || BITCOIN; // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var hd; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');\n    var k = buffer.slice(46, 78);\n    hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var X = buffer.slice(45, 78);\n    hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n  }\n\n  return hd;\n}\n\nexports.fromBase58 = fromBase58;\n\nfunction fromPrivateKey(privateKey, chainCode, network) {\n  return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, {\n    privateKey: privateKey,\n    chainCode: chainCode\n  });\n  network = network || BITCOIN;\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');\n  return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromPublicKey(publicKey, chainCode, network) {\n  return fromPublicKeyLocal(publicKey, chainCode, network);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, {\n    publicKey: publicKey,\n    chainCode: chainCode\n  });\n  network = network || BITCOIN; // verify the X coordinate is a point on the curve\n\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');\n  return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromSeed(seed, network) {\n  typeforce(typeforce.Buffer, seed);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  network = network || BITCOIN;\n  var I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return fromPrivateKey(IL, IR, network);\n}\n\nexports.fromSeed = fromSeed;","map":{"version":3,"sources":["/home/amro/MirrorProtocol/eth-web-app/node_modules/bip32/src/bip32.js"],"names":["Object","defineProperty","exports","value","crypto","require","bs58check","ecc","typeforce","wif","UINT256_TYPE","BufferN","NETWORK_TYPE","compile","UInt8","bip32","public","UInt32","private","BITCOIN","messagePrefix","bech32","pubKeyHash","scriptHash","HIGHEST_BIT","UINT31_MAX","Math","pow","BIP32Path","String","match","UInt31","BIP32","__D","__Q","chainCode","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","lowR","undefined","fromPublicKeyLocal","publicKey","depth","index","parentFingerprint","version","isNeutered","buffer","Buffer","allocUnsafe","writeUInt32BE","writeUInt8","copy","privateKey","encode","TypeError","isHardened","data","I","hmacSHA512","IL","slice","IR","isPrivate","derive","hd","ki","privateAdd","fromPrivateKeyLocal","fingerprint","readUInt32BE","Ki","pointAddScalar","path","splitPath","split","reduce","prevHd","indexStr","parseInt","deriveHardened","hash","Error","sign","sig","extraData","alloc","counter","writeUIntLE","signWithEntropy","signature","verify","pointFromScalar","hash160","identifier","fromBase58","inString","decode","length","readUInt8","k","X","fromPrivateKey","fromPublicKey","isPoint","fromSeed","seed","from"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n"]},"metadata":{},"sourceType":"script"}