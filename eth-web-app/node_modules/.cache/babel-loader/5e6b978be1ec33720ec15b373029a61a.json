{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, canUseWeakMap } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, isFieldValueToBeMerged, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport var defaultDataIdFromObject = function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (id === void 0) id = _id;\n\n    if (id !== void 0) {\n      return __typename + \":\" + (typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n};\n\nvar nullKeyFieldsFn = function nullKeyFieldsFn() {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function simpleKeyArgsFn(_args, context) {\n  return context.fieldName;\n};\n\nvar mergeTrueFn = function mergeTrueFn(existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function mergeFalseFn(_, incoming) {\n  return incoming;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.supertypeMap = new Map();\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n          fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n          var incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n                read = incoming.read,\n                merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n          }\n\n          if (existing.read && existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 1) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      _this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n\n        var match = subtype.match(TypeOrFieldNameRegExp);\n\n        if (!match || match[0] !== subtype) {\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    if (typename) {\n      return this.typePolicies[typename] || createIfMissing && (this.typePolicies[typename] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n\n    return supertypeSet;\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n\n      var maybeEnqueue_1 = function maybeEnqueue_1(subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              process.env.NODE_ENV === \"production\" || invariant.warn(\"Inferring subtype \" + typename + \" of supertype \" + supertype);\n            }\n\n            typenameSupertypeSet.add(supertype);\n          }\n\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue_1);\n\n        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n\n  Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n    var _a;\n\n    var _this = this;\n\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n      incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, {\n        typename: incoming.__typename,\n        fieldName: fieldName,\n        field: field,\n        variables: context.variables\n      }, context, storageKeys ? (_a = context.store).getStorage.apply(_a, storageKeys) : Object.create(null)));\n    }\n\n    if (Array.isArray(incoming)) {\n      return incoming.map(function (item) {\n        return _this.applyMerges(void 0, item, context);\n      });\n    }\n\n    if (storeValueIsStoreObject(incoming)) {\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      var newFields_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        var incomingValue = i_1[storeFieldName];\n\n        var appliedValue = _this.applyMerges(context.store.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n\n        if (appliedValue !== incomingValue) {\n          newFields_1 = newFields_1 || Object.create(null);\n          newFields_1[storeFieldName] = appliedValue;\n        }\n      });\n\n      if (newFields_1) {\n        return __assign(__assign({}, i_1), newFields_1);\n      }\n    }\n\n    return incoming;\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      getFieldValue = _a.getFieldValue,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function readField(fieldNameOrOptions, from) {\n      var options = typeof fieldNameOrOptions === \"string\" ? {\n        fieldName: fieldNameOrOptions,\n        from: from\n      } : __assign({}, fieldNameOrOptions);\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField(options, context);\n    },\n    mergeObjects: function mergeObjects(existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(2) : new InvariantError(\"Cannot automatically merge arrays\");\n      }\n\n      if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n        var eType = getFieldValue(existing, \"__typename\");\n        var iType = getFieldValue(incoming, \"__typename\");\n        var typesDiffer = eType && iType && eType !== iType;\n        var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n\n        if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(applied)) {\n          return applied;\n        }\n\n        return __assign(__assign({}, existing), applied);\n      }\n\n      return incoming;\n    }\n  };\n}\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 3) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/policies.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from 'graphql';\n\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  FragmentMap,\n  getFragmentFromSelection,\n  isField,\n  getTypenameFromResult,\n  storeKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  argumentsObjectFromField,\n  Reference,\n  isReference,\n  getStoreKeyName,\n  canUseWeakMap,\n} from '../../utilities';\nimport { IdGetter, ReadMergeModifyContext } from \"./types\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  FieldValueToBeMerged,\n  isFieldValueToBeMerged,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n} from './helpers';\nimport { cacheSlot } from './reactiveVars';\nimport { InMemoryCache } from './inMemoryCache';\nimport {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from '../core/types/common';\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n}\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\ntype KeySpecifier = (string | any[])[];\n\ntype KeyFieldsContext = {\n  typename?: string;\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n  // May be set by the KeyFieldsFunction to report fields that were involved\n  // in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext,\n) => KeySpecifier | ReturnType<IdGetter>;\n\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<any>\n      | FieldReadFunction<any>;\n  }\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => KeySpecifier | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  TExisting = any,\n  TIncoming = TExisting,\n  TReadResult = TExisting,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult>;\n  merge?: FieldMergeFunction<TExisting, TIncoming> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0 ? spec.args :\n    spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects<T extends StoreObject | Reference>(\n    existing: T,\n    incoming: T,\n  ): T | undefined;\n}\n\nexport type FieldReadFunction<TExisting = any, TReadResult = TExisting> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: FieldFunctionOptions,\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<TExisting = any, TIncoming = TExisting> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: FieldFunctionOptions,\n) => SafeReadonly<TExisting>;\n\nexport const defaultDataIdFromObject = (\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n) => {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n         id !== void 0 ? {  id } :\n        _id !== void 0 ? { _id } :\n        void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (id === void 0) id = _id;\n    if (id !== void 0) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n};\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> =\n  (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      fields?: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> = Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(private config: {\n    cache: InMemoryCache;\n    dataIdFromObject?: KeyFieldsFunction;\n    possibleTypes?: PossibleTypesMap;\n    typePolicies?: TypePolicies;\n  }) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    selectionSet?: SelectionSetNode,\n    fragmentMap?: FragmentMap,\n  ): [string?, StoreObject?] {\n    // TODO Consider subtypes?\n    // TODO Use an AliasMap here?\n    const typename = selectionSet && fragmentMap\n      ? getTypenameFromResult(object, selectionSet, fragmentMap)\n      : object.__typename;\n\n    // It should be possible to write root Query fields with\n    // writeFragment, using { __typename: \"Query\", ... } as the data, but\n    // it does not make sense to allow the same identification behavior\n    // for the Mutation and Subscription types, since application code\n    // should never be writing directly to (or reading directly from)\n    // those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    const context: KeyFieldsContext = {\n      typename,\n      selectionSet,\n      fragmentMap,\n    };\n\n    let id: string | undefined;\n\n    const policy = this.getTypePolicy(typename, false);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn(object, context);\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const existing = this.getTypePolicy(typename, true)!;\n      const incoming = typePolicies[typename];\n      const { keyFields, fields } = incoming;\n\n      if (incoming.queryType) this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      existing.keyFn =\n        // Pass false to disable normalization for this typename.\n        keyFields === false ? nullKeyFieldsFn :\n        // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n        Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n        // Pass a function to take full control over identification.\n        typeof keyFields === \"function\" ? keyFields :\n        // Leave existing.keyFn unchanged if above cases fail.\n        existing.keyFn;\n\n      if (fields) {\n        Object.keys(fields).forEach(fieldName => {\n          const existing = this.getFieldPolicy(typename, fieldName, true)!;\n          const incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            const { keyArgs, read, merge } = incoming;\n\n            existing.keyFn =\n              // Pass false to disable argument-based differentiation of\n              // field identities.\n              keyArgs === false ? simpleKeyArgsFn :\n              // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n              Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n              // Pass a function to take full control over field identity.\n              typeof keyArgs === \"function\" ? keyArgs :\n              // Leave existing.keyFn unchanged if above cases fail.\n              existing.keyFn;\n\n            if (typeof read === \"function\") existing.read = read;\n\n            existing.merge =\n              typeof merge === \"function\" ? merge :\n              // Pass merge:true as a shorthand for a merge implementation\n              // that returns options.mergeObjects(existing, incoming).\n              merge === true ? mergeTrueFn :\n              // Pass merge:false to make incoming always replace existing\n              // without any warnings about data clobbering.\n              merge === false ? mergeFalseFn :\n              existing.merge;\n          }\n\n          if (existing.read && existing.merge) {\n            // If we have both a read and a merge function, assume\n            // keyArgs:false, because read and merge together can take\n            // responsibility for interpreting arguments in and out. This\n            // default assumption can always be overridden by specifying\n            // keyArgs explicitly in the FieldPolicy.\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which,\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, `Cannot change root ${which} __typename more than once`);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(\n    typename: string | undefined,\n    createIfMissing: boolean,\n  ): Policies[\"typePolicies\"][string] | undefined {\n    if (typename) {\n      return this.typePolicies[typename] || (\n        createIfMissing && (this.typePolicies[typename] = Object.create(null)));\n    }\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean,\n  ): {\n    keyFn?: KeyArgsFunction;\n    read?: FieldReadFunction<any>;\n    merge?: FieldMergeFunction<any>;\n  } | undefined {\n    const typePolicy = this.getTypePolicy(typename, createIfMissing);\n    if (typePolicy) {\n      const fieldPolicies = typePolicy.fields || (\n        createIfMissing && (typePolicy.fields = Object.create(null)));\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || (\n          createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n      }\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean,\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set<string>());\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>,\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes &&\n        this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet &&\n            supertypeSet.size &&\n            workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(`Inferring subtype ${typename} of supertype ${supertype}`);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (needToCheckFuzzySubtypes &&\n            // Start checking fuzzy subtypes only after exhausting all\n            // non-fuzzy subtypes (after the final iteration of the loop).\n            i === workQueue.length - 1 &&\n            // We could wait to compare fragment.selectionSet to result\n            // after we verify the supertype, but this check is often less\n            // expensive than that search, and we will have to do the\n            // comparison anyway whenever we find a potential match.\n            selectionSetMatchesResult(fragment.selectionSet, result!, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: string | undefined;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext,\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName,\n        ),\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(\n        this.cache,\n        read,\n        [existing, readOptions],\n      ) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public hasMergeFunction(\n    typename: string | undefined,\n    fieldName: string,\n  ) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  }\n\n  public applyMerges<T extends StoreValue>(\n    existing: T | Reference,\n    incoming: T | FieldValueToBeMerged,\n    context: ReadMergeModifyContext,\n    storageKeys?: [string | StoreObject, string],\n  ): T {\n    if (isFieldValueToBeMerged(incoming)) {\n      const field = incoming.__field;\n      const fieldName = field.name.value;\n      // This policy and its merge function are guaranteed to exist\n      // because the incoming value is a FieldValueToBeMerged object.\n      const { merge } = this.getFieldPolicy(\n        incoming.__typename, fieldName, false)!;\n\n      incoming = merge!(existing, incoming.__value, makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        { typename: incoming.__typename,\n          fieldName,\n          field,\n          variables: context.variables },\n        context,\n        storageKeys\n          ? context.store.getStorage(...storageKeys)\n          : Object.create(null),\n      )) as T;\n    }\n\n    if (Array.isArray(incoming)) {\n      return incoming!.map(item => this.applyMerges(\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so there is no basis for\n        // merging them. Passing void here means any FieldValueToBeMerged\n        // objects within item will be handled as if there was no existing\n        // data. Also, we do not pass storageKeys because the array itself\n        // is never an entity with a __typename, so its indices can never\n        // have custom read or merge functions.\n        void 0,\n        item,\n        context,\n      )) as T;\n    }\n\n    if (storeValueIsStoreObject(incoming)) {\n      const e = existing as StoreObject | Reference;\n      const i = incoming as StoreObject;\n\n      // If the existing object is a { __ref } object, e.__ref provides a\n      // stable key for looking up the storage object associated with\n      // e.__ref and storeFieldName. Otherwise, storage is enabled only if\n      // existing is actually a non-null object. It's less common for a\n      // merge function to use options.storage, but it's conceivable that a\n      // pair of read and merge functions might want to cooperate in\n      // managing their shared options.storage object.\n      const firstStorageKey = isReference(e)\n        ? e.__ref\n        : typeof e === \"object\" && e;\n\n      let newFields: StoreObject | undefined;\n\n      Object.keys(i).forEach(storeFieldName => {\n        const incomingValue = i[storeFieldName];\n        const appliedValue = this.applyMerges(\n          context.store.getFieldValue(e, storeFieldName),\n          incomingValue,\n          context,\n          // Avoid enabling options.storage when firstStorageKey is falsy,\n          // which implies no options.storage object has ever been created\n          // for a read/merge function for this field.\n          firstStorageKey ? [firstStorageKey, storeFieldName] : void 0,\n        );\n        if (appliedValue !== incomingValue) {\n          newFields = newFields || Object.create(null);\n          newFields![storeFieldName] = appliedValue;\n        }\n      });\n\n      if (newFields) {\n        return { ...i, ...newFields } as typeof incoming;\n      }\n    }\n\n    return incoming;\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { getFieldValue, toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n\n    readField<T>(\n      fieldNameOrOptions: string | ReadFieldOptions,\n      from?: StoreObject | Reference,\n    ) {\n      const options: ReadFieldOptions =\n        typeof fieldNameOrOptions === \"string\" ? {\n          fieldName: fieldNameOrOptions,\n          from,\n        } : { ...fieldNameOrOptions };\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField<T>(options, context);\n    },\n\n    mergeObjects(existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw new InvariantError(\"Cannot automatically merge arrays\");\n      }\n\n      // These dynamic checks are necessary because the parameters of a\n      // custom merge function can easily have the any type, so the type\n      // system cannot always enforce the StoreObject | Reference\n      // parameter types of options.mergeObjects.\n      if (existing && typeof existing === \"object\" &&\n          incoming && typeof incoming === \"object\") {\n        const eType = getFieldValue(existing, \"__typename\");\n        const iType = getFieldValue(incoming, \"__typename\");\n        const typesDiffer = eType && iType && eType !== iType;\n\n        const applied = policies.applyMerges(\n          typesDiffer ? void 0 : existing,\n          incoming,\n          context,\n        );\n\n        if (\n          typesDiffer ||\n          !storeValueIsStoreObject(existing) ||\n          !storeValueIsStoreObject(applied)\n        ) {\n          return applied;\n        }\n\n        return { ...existing, ...applied };\n      }\n\n      return incoming;\n    }\n  };\n}\n\nfunction keyArgsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyArgsFunction {\n  return (args, context) => {\n    return args ? `${context.fieldName}:${\n      JSON.stringify(computeKeyObject(args, specifier))\n    }` : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyFieldsFunction {\n  const trie = new KeyTrie<{\n    aliasMap?: AliasMap;\n  }>(canUseWeakMap);\n\n  return (object, context) => {\n    let aliasMap: AliasMap | undefined;\n    if (context.selectionSet && context.fragmentMap) {\n      const info = trie.lookupArray([\n        context.selectionSet,\n        context.fragmentMap,\n      ]);\n      aliasMap = info.aliasMap || (\n        info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap)\n      );\n    }\n\n    const keyObject = context.keyObject =\n      computeKeyObject(object, specifier, aliasMap);\n\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  };\n}\n\ntype AliasMap = {\n  // Map from store key to corresponding response key. Undefined when there are\n  // no aliased fields in this selection set.\n  aliases?: Record<string, string>;\n  // Map from store key to AliasMap correponding to a child selection set.\n  // Undefined when there are no child selection sets.\n  subsets?: Record<string, AliasMap>;\n};\n\nfunction makeAliasMap(\n  selectionSet: SelectionSetNode,\n  fragmentMap: FragmentMap,\n): AliasMap {\n  let map: AliasMap = Object.create(null);\n  // TODO Cache this work, perhaps by storing selectionSet._aliasMap?\n  const workQueue = new Set([selectionSet]);\n  workQueue.forEach(selectionSet => {\n    selectionSet.selections.forEach(selection => {\n      if (isField(selection)) {\n        if (selection.alias) {\n          const responseKey = selection.alias.value;\n          const storeKey = selection.name.value;\n          if (storeKey !== responseKey) {\n            const aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n        if (selection.selectionSet) {\n          const subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] =\n            makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        const fragment = getFragmentFromSelection(selection, fragmentMap);\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(\n  response: Record<string, any>,\n  specifier: KeySpecifier,\n  aliasMap?: AliasMap,\n): Record<string, any> {\n  // The order of adding properties to keyObj affects its JSON serialization,\n  // so we are careful to build keyObj in the order of keys given in\n  // specifier.\n  const keyObj = Object.create(null);\n  let prevKey: string | undefined;\n  specifier.forEach(s => {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        const subsets = aliasMap && aliasMap.subsets;\n        const subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      const aliases = aliasMap && aliasMap.aliases;\n      const responseName = aliases && aliases[s] || s;\n      invariant(\n        hasOwn.call(response, responseName),\n        // TODO Make this appropriate for keyArgs as well\n        `Missing field '${responseName}' while computing key fields`,\n      );\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}